{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\u200b\\-]"},"docs":[{"location":"","text":"F5 BIG-IP Kubernetes Gateway online docs \u00b6 Welcome. This is the online docs of F5 BIG-IP kubernetes Gateway. F5 BIG-IP kubernetes Gateway is an implementation of K8S Gateway API at v0.5.1 . For a list of supported Gateway API resources and features, see the Gateway API Compatibility doc. Check here for Gateway API's latest status. Source code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway . Welcome join us, you can get help in the slack channel #oss-bigip-kubernetes-gateway or Wechat . Click here , see the latest release.","title":"Overview"},{"location":"#f5-big-ip-kubernetes-gateway-online-docs","text":"Welcome. This is the online docs of F5 BIG-IP kubernetes Gateway. F5 BIG-IP kubernetes Gateway is an implementation of K8S Gateway API at v0.5.1 . For a list of supported Gateway API resources and features, see the Gateway API Compatibility doc. Check here for Gateway API's latest status. Source code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway . Welcome join us, you can get help in the slack channel #oss-bigip-kubernetes-gateway or Wechat . Click here , see the latest release.","title":"F5 BIG-IP Kubernetes Gateway online docs"},{"location":"Architecture/","text":"Overview \u00b6 This project is one kind of Gateway API downstream implementations and integrations. It leverages the Kubernetes development kit Operator pattern and Controllers for the implementation. Resource Correspondence to BIG-IP Provider \u00b6 The correspondence between gateway-related resources and BIG-IP resources is as follows: From the above figure, we can see the correspondence between gateway-related resources and resources on BIG-IP. When using BIG-IP as a provider, the specific form of each gateway resource on BIG-IP is: K8S Resources BIG-IP Resources Controller BIG-IP Device GatewayClass Partition Gateway Virtual HTTPRoute iRule Service Pool Deploy ( pods ) Member Program Architecture and Workflow Design \u00b6 Basically, bigip-kubernetes-gateway architecture is designed as follows: It uses controller-runtime framework to connect to the k8s cluster side and receive user operation events on various resources such as GatewayClass , Gateway , HTTPRoute , Service , etc. It uses f5-bigip-rest module to do resource deliveries and deployments to BIG-IP via iControl REST. Between the upstream and downstream, it uses a queue to decouple event processing and delivery logic.","title":"Overview"},{"location":"Architecture/#overview","text":"This project is one kind of Gateway API downstream implementations and integrations. It leverages the Kubernetes development kit Operator pattern and Controllers for the implementation.","title":"Overview"},{"location":"Architecture/#resource-correspondence-to-big-ip-provider","text":"The correspondence between gateway-related resources and BIG-IP resources is as follows: From the above figure, we can see the correspondence between gateway-related resources and resources on BIG-IP. When using BIG-IP as a provider, the specific form of each gateway resource on BIG-IP is: K8S Resources BIG-IP Resources Controller BIG-IP Device GatewayClass Partition Gateway Virtual HTTPRoute iRule Service Pool Deploy ( pods ) Member","title":"Resource Correspondence to BIG-IP Provider"},{"location":"Architecture/#program-architecture-and-workflow-design","text":"Basically, bigip-kubernetes-gateway architecture is designed as follows: It uses controller-runtime framework to connect to the k8s cluster side and receive user operation events on various resources such as GatewayClass , Gateway , HTTPRoute , Service , etc. It uses f5-bigip-rest module to do resource deliveries and deployments to BIG-IP via iControl REST. Between the upstream and downstream, it uses a queue to decouple event processing and delivery logic.","title":"Program Architecture and Workflow Design"},{"location":"Architecture/gatewayclassrefer/","text":"GatewayClass and BIG-IP References \u00b6 Relationships Between GatewayClass, Controller and BIG-IP \u00b6 There is an n-1-1 relationship between GatewayClass , Controller and BIG-IP. Controller and BIG-IP are one-to-one relationships, and BIG-IP here can be understood as a set of BIG-IP, such as two BIG-IPs are HA relationships with each other. In the same K8S cluster, a controller controls a group of BIG-IPs and is responsible for different gatewayClasses. The relationship between GatewayClass and Controller is designed as a many-to-one relationship, that is, multiple gatewayclasses can correspond to the same BIG-IP, the name field of the GatewayClass resource is mapped as the partition name on the BIG-IP, and the gateway-related resources associated with the GatewayClass will be created as ltm resources under that partition. The mapping between GatewayClass and Controller is achieved through the following properties: controllerName in GatewayClass <=> --controller-name The controllerName field corresponds to the --controllerName parameter at startup, if this field cannot match the --controllerName parameter, this gatewayclass resource will not be processed by the controller. gatewayclass.yaml: --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name # parametersRef in the gatewayclass resource configuration will be ignored. # parametersRef: # group: # kind: # name: # namespace: When the GatewayClass Resource Changes \u00b6 When the user changes the name of the GatewayClass, it means that the user deletes the original GatewayClass and creates a new GatewayClass. Controller will erase the partition corresponding to the GatewayClass name and all resources under it on the BIG-IP. Then the controller creates a new partiton of the GatewayClass name and rebuild the partition's resources. Therefore, for users, changing the GatewayClass name needs to be cautious.","title":"BIG-IP Providers"},{"location":"Architecture/gatewayclassrefer/#gatewayclass-and-big-ip-references","text":"","title":"GatewayClass and BIG-IP References"},{"location":"Architecture/gatewayclassrefer/#relationships-between-gatewayclass-controller-and-big-ip","text":"There is an n-1-1 relationship between GatewayClass , Controller and BIG-IP. Controller and BIG-IP are one-to-one relationships, and BIG-IP here can be understood as a set of BIG-IP, such as two BIG-IPs are HA relationships with each other. In the same K8S cluster, a controller controls a group of BIG-IPs and is responsible for different gatewayClasses. The relationship between GatewayClass and Controller is designed as a many-to-one relationship, that is, multiple gatewayclasses can correspond to the same BIG-IP, the name field of the GatewayClass resource is mapped as the partition name on the BIG-IP, and the gateway-related resources associated with the GatewayClass will be created as ltm resources under that partition. The mapping between GatewayClass and Controller is achieved through the following properties: controllerName in GatewayClass <=> --controller-name The controllerName field corresponds to the --controllerName parameter at startup, if this field cannot match the --controllerName parameter, this gatewayclass resource will not be processed by the controller. gatewayclass.yaml: --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name # parametersRef in the gatewayclass resource configuration will be ignored. # parametersRef: # group: # kind: # name: # namespace:","title":"Relationships Between GatewayClass, Controller and BIG-IP"},{"location":"Architecture/gatewayclassrefer/#when-the-gatewayclass-resource-changes","text":"When the user changes the name of the GatewayClass, it means that the user deletes the original GatewayClass and creates a new GatewayClass. Controller will erase the partition corresponding to the GatewayClass name and all resources under it on the BIG-IP. Then the controller creates a new partiton of the GatewayClass name and rebuild the partition's resources. Therefore, for users, changing the GatewayClass name needs to be cautious.","title":"When the GatewayClass Resource Changes"},{"location":"Architecture/resources-layout/","text":"Resource Management \u00b6 The four resources of GatewayClass Gateway HTTPRoute Service are related to each other to form a tree-like association, of which GatewayClass is the root. The following figure shows the analogy relationships of resources on BIG-IP: However, 2 bit differences with forming a tree are: A HTTPROUTE resource can be referenced by multiple Gateway from the same or different GatewayClass . A Service resource can be referenced by multiple HTTPROUTE of any namespaces. The 2 differences are shown as the orange-colored R and S : In the figure above, G stands for Gateway, R stands for HTTPRoute, S stands for Service. The gwc1 gwc2 gwc3 are three gatewayClass resources, they are all attached to the same BIG-IP x. Gateway-related resources will be distributed to the associated partitions with gatewayclass name, including Gateway and HTTPRoute . It should be noted that: In the above figure, there are 2 gateways under gwc1 and gwc3 that references the same HTTPRoute , in this case, the HTTPRoute resource is logically the same resource, but the actual deliveries are two iRules with the same content, located under gwc1 and gwc2 partitions . In the figure above, iRules in two partitions gwc1 and gwc3 refer to the same service, the pool converted from this service is unique . HTTPRoute resources do not contain partition information, so only when the associated Gateway resource being created can it be determined which partition its corresponding irule should be deployed in, so HTTPRoute without any Gateway association will not be sent immediately, but will be cached until it is referenced by a virtual. The Service information associated with HTTPRoute will be deployed in the form of a pool to a specific partition \" cis-c-tenant \". The pool name is \"\\ .\\ \". In the future, it may change according to customer needs, such as distributed to a partition named as Service 's namespace.","title":"Resource Layout"},{"location":"Architecture/resources-layout/#resource-management","text":"The four resources of GatewayClass Gateway HTTPRoute Service are related to each other to form a tree-like association, of which GatewayClass is the root. The following figure shows the analogy relationships of resources on BIG-IP: However, 2 bit differences with forming a tree are: A HTTPROUTE resource can be referenced by multiple Gateway from the same or different GatewayClass . A Service resource can be referenced by multiple HTTPROUTE of any namespaces. The 2 differences are shown as the orange-colored R and S : In the figure above, G stands for Gateway, R stands for HTTPRoute, S stands for Service. The gwc1 gwc2 gwc3 are three gatewayClass resources, they are all attached to the same BIG-IP x. Gateway-related resources will be distributed to the associated partitions with gatewayclass name, including Gateway and HTTPRoute . It should be noted that: In the above figure, there are 2 gateways under gwc1 and gwc3 that references the same HTTPRoute , in this case, the HTTPRoute resource is logically the same resource, but the actual deliveries are two iRules with the same content, located under gwc1 and gwc2 partitions . In the figure above, iRules in two partitions gwc1 and gwc3 refer to the same service, the pool converted from this service is unique . HTTPRoute resources do not contain partition information, so only when the associated Gateway resource being created can it be determined which partition its corresponding irule should be deployed in, so HTTPRoute without any Gateway association will not be sent immediately, but will be cached until it is referenced by a virtual. The Service information associated with HTTPRoute will be deployed in the form of a pool to a specific partition \" cis-c-tenant \". The pool name is \"\\ .\\ \". In the future, it may change according to customer needs, such as distributed to a partition named as Service 's namespace.","title":"Resource Management"},{"location":"Operation-and-troubleshooting/ki/","text":"Known Issues \u00b6 No issue yet. Please report your issue or suggestion on https://github.com/f5devcentral/bigip-kubernetes-gateway/issues .","title":"Common FAQ"},{"location":"Operation-and-troubleshooting/ki/#known-issues","text":"No issue yet. Please report your issue or suggestion on https://github.com/f5devcentral/bigip-kubernetes-gateway/issues .","title":"Known Issues"},{"location":"Operation-and-troubleshooting/trubeshooting/","text":"Trouble Shooting \u00b6 Use the following command to trace or detect any issue: $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system Will continously complement this section in the future.","title":"Troubleshooting"},{"location":"Operation-and-troubleshooting/trubeshooting/#trouble-shooting","text":"Use the following command to trace or detect any issue: $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system Will continously complement this section in the future.","title":"Trouble Shooting"},{"location":"Release-notes/","text":"Releases \u00b6 The bigip-kubernetes-gateway versions are released on dockerhub as Docker images . The code repository is f5devcentral/bigip-kubernetes-gateway . Release v0.1.1 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.1.1-20230111 Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Refine conroller's logging Feature Support \u00b6 Add Support for Gateway.Listener.AllowedRouted Spec. See more details from the PR and the Usecase Add AS configuration for calico mode. Documentation Support \u00b6 Update compatibility docs Release v0.1.0 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.1.0-20221226 Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Supports full DevOps capabilities, providing all YAML files for installation and deployment. Uses github action for the integration with Slack . Feature Support \u00b6 Supports using configmap as the controller's parameter format Supports the ability to deliver and configure resources to BIG-IP, refer to gateway api compatibility , also, refer to all usecases . Supports integration with Prometheus to capture controller performance data. Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks. Supports log tracing with request id. Supports automated configuration of flannel and calico CNI modes on the BIG-IP side. Documentation Support \u00b6 Documentation on https://gateway-api.f5se.io/ . Release v0.0.4 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 Improve the automated configuration of the BIG-IP side in flannel and calico modes, see here Determine the parameters passed in by the user, see here Fixed the partition deletion issue when the gatewayclass was deleted, see here Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.3...v0.0.4 Release v0.0.3 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.3-20221213 Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 Documentation on https://gateway-api.f5se.io/ , including: Update usage of deploy/install controller Add gateway api compatibility reference Add LICENSE declaration Use github action for the integration with Slack. Redesign gatewayclass and controller relationship that moves BIG-IP configuration to controller level. Add controller parameter form of configmap . Add BIG-IP configuration ability for flannel and calico CNIs( here ). Enable log tracing with request id. Implement httproute traffic splitting feature ( here ). Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.2...v0.0.3 Release v0.0.2 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.2-20221129 Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 Add support for gatewayclass resources, see gatewayclass design . Implement the ability of handling disorder events for kinds of resources. Improve the design and usage documentation: https://gateway-api.f5se.io/ Optimize the resource synchronization mode at startup time for deployment integrity. Update the f5-bigip-rest dependency for better deployments. Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.1...v0.0.2 Release v0.0.1 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.1-20221115 Deployment Reference: \u00b6 https://gateway-api.f5se.io/quick-start/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Supports full DevOps capabilities, providing all YAML files for installation and deployment. Supports integration with Prometheus to capture controller performance data Basic automated testing capabilities. Feature Support \u00b6 Supports the ability to deliver and configure resources: gateway httproute and service deployment, to BIG-IP. Supports resource specs: gatewayclass: not support gateway\uff1a listeners\uff1aname port protocol addresses\uff1avalue httproute parentRefs hostnames rules matches: method header path queryParams filters: RequestHeaderModifier RequestRedirect ExtensionRef backendRefs: partial, only one backend supported Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks.","title":"Releases"},{"location":"Release-notes/#releases","text":"The bigip-kubernetes-gateway versions are released on dockerhub as Docker images . The code repository is f5devcentral/bigip-kubernetes-gateway .","title":"Releases"},{"location":"Release-notes/#release-v011","text":"","title":"Release v0.1.1"},{"location":"Release-notes/#docker-image","text":"f5devcentral/bigip-kubernetes-gateway:v0.1.1-20230111","title":"Docker Image:"},{"location":"Release-notes/#reference","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support","text":"Refine conroller's logging","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support","text":"Add Support for Gateway.Listener.AllowedRouted Spec. See more details from the PR and the Usecase Add AS configuration for calico mode.","title":"Feature Support"},{"location":"Release-notes/#documentation-support","text":"Update compatibility docs","title":"Documentation Support"},{"location":"Release-notes/#release-v010","text":"","title":"Release v0.1.0"},{"location":"Release-notes/#docker-image_1","text":"f5devcentral/bigip-kubernetes-gateway:v0.1.0-20221226","title":"Docker Image:"},{"location":"Release-notes/#reference_1","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_1","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_1","text":"Supports full DevOps capabilities, providing all YAML files for installation and deployment. Uses github action for the integration with Slack .","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_1","text":"Supports using configmap as the controller's parameter format Supports the ability to deliver and configure resources to BIG-IP, refer to gateway api compatibility , also, refer to all usecases . Supports integration with Prometheus to capture controller performance data. Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks. Supports log tracing with request id. Supports automated configuration of flannel and calico CNI modes on the BIG-IP side.","title":"Feature Support"},{"location":"Release-notes/#documentation-support_1","text":"Documentation on https://gateway-api.f5se.io/ .","title":"Documentation Support"},{"location":"Release-notes/#release-v004","text":"","title":"Release v0.0.4"},{"location":"Release-notes/#docker-image_2","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219","title":"Docker Image:"},{"location":"Release-notes/#reference_2","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_2","text":"Improve the automated configuration of the BIG-IP side in flannel and calico modes, see here Determine the parameters passed in by the user, see here Fixed the partition deletion issue when the gatewayclass was deleted, see here Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.3...v0.0.4","title":"Release Notes:"},{"location":"Release-notes/#release-v003","text":"","title":"Release v0.0.3"},{"location":"Release-notes/#docker-image_3","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.3-20221213","title":"Docker Image:"},{"location":"Release-notes/#reference_3","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_3","text":"Documentation on https://gateway-api.f5se.io/ , including: Update usage of deploy/install controller Add gateway api compatibility reference Add LICENSE declaration Use github action for the integration with Slack. Redesign gatewayclass and controller relationship that moves BIG-IP configuration to controller level. Add controller parameter form of configmap . Add BIG-IP configuration ability for flannel and calico CNIs( here ). Enable log tracing with request id. Implement httproute traffic splitting feature ( here ). Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.2...v0.0.3","title":"Release Notes:"},{"location":"Release-notes/#release-v002","text":"","title":"Release v0.0.2"},{"location":"Release-notes/#docker-image_4","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.2-20221129","title":"Docker Image:"},{"location":"Release-notes/#reference_4","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_4","text":"Add support for gatewayclass resources, see gatewayclass design . Implement the ability of handling disorder events for kinds of resources. Improve the design and usage documentation: https://gateway-api.f5se.io/ Optimize the resource synchronization mode at startup time for deployment integrity. Update the f5-bigip-rest dependency for better deployments. Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.1...v0.0.2","title":"Release Notes:"},{"location":"Release-notes/#release-v001","text":"","title":"Release v0.0.1"},{"location":"Release-notes/#docker-image_5","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.1-20221115","title":"Docker Image:"},{"location":"Release-notes/#deployment-reference","text":"https://gateway-api.f5se.io/quick-start/installation/","title":"Deployment Reference:"},{"location":"Release-notes/#release-notes_5","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_2","text":"Supports full DevOps capabilities, providing all YAML files for installation and deployment. Supports integration with Prometheus to capture controller performance data Basic automated testing capabilities.","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_2","text":"Supports the ability to deliver and configure resources: gateway httproute and service deployment, to BIG-IP. Supports resource specs: gatewayclass: not support gateway\uff1a listeners\uff1aname port protocol addresses\uff1avalue httproute parentRefs hostnames rules matches: method header path queryParams filters: RequestHeaderModifier RequestRedirect ExtensionRef backendRefs: partial, only one backend supported Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks.","title":"Feature Support"},{"location":"Support-and-contact/","text":"Support and contact \u00b6 For the gateway controller support: \u00b6 Please ask questions or open issues on github Issues For the online docs support: \u00b6 Please ask questions or open issues on github Issues Welcome to contact us by below ways: \u00b6 Slack channel (for global users) Join the f5CloudSolutions Slack workspace first. After joining in the workspace, login into the workspace, find channel #oss-bigip-kubernetes-gateway and join it. Wechat group (for China Wechat users only) zongzw","title":"Tech Support"},{"location":"Support-and-contact/#support-and-contact","text":"","title":"Support and contact"},{"location":"Support-and-contact/#for-the-gateway-controller-support","text":"Please ask questions or open issues on github Issues","title":"For the gateway controller support:"},{"location":"Support-and-contact/#for-the-online-docs-support","text":"Please ask questions or open issues on github Issues","title":"For the online docs support:"},{"location":"Support-and-contact/#welcome-to-contact-us-by-below-ways","text":"Slack channel (for global users) Join the f5CloudSolutions Slack workspace first. After joining in the workspace, login into the workspace, find channel #oss-bigip-kubernetes-gateway and join it. Wechat group (for China Wechat users only) zongzw","title":"Welcome to contact us by below ways:"},{"location":"Support-and-contact/contributions/","text":"Wecome any contributions \u00b6 For online docs, kindly please PR to docs repository For coding contribution kindly please refer the guide in the code repository . Here are the contributors for now\uff1a zongzw f5zong Niklaus-xie myf5 Jing Lin License \u00b6 Copyright 2022. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Contributions"},{"location":"Support-and-contact/contributions/#wecome-any-contributions","text":"For online docs, kindly please PR to docs repository For coding contribution kindly please refer the guide in the code repository . Here are the contributors for now\uff1a zongzw f5zong Niklaus-xie myf5 Jing Lin","title":"Wecome any contributions"},{"location":"Support-and-contact/contributions/#license","text":"Copyright 2022. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"Use-Cases/grpc-routing/","text":"gRPC routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"gRPC Routing"},{"location":"Use-Cases/grpc-routing/#grpc-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"gRPC routing"},{"location":"Use-Cases/http-redirect-rewrite/","text":"HTTP path redirects and rewrites \u00b6 HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Redirects \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently . Rewrites \u00b6 Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"HTTP Redirects and Rewrites"},{"location":"Use-Cases/http-redirect-rewrite/#http-path-redirects-and-rewrites","text":"HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP path redirects and rewrites"},{"location":"Use-Cases/http-redirect-rewrite/#redirects","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently .","title":"Redirects"},{"location":"Use-Cases/http-redirect-rewrite/#rewrites","text":"Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"Rewrites"},{"location":"Use-Cases/http-routing/","text":"HTTP Routing \u00b6 In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Request header based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80. Request method based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80. Request path based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80. Request parameter based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80. Multiple matches in a HTTPRoute \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"HTTP Routing"},{"location":"Use-Cases/http-routing/#http-routing","text":"In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP Routing"},{"location":"Use-Cases/http-routing/#request-header-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80.","title":"Request header based matching"},{"location":"Use-Cases/http-routing/#request-method-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80.","title":"Request method based matching"},{"location":"Use-Cases/http-routing/#request-path-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80.","title":"Request path based matching"},{"location":"Use-Cases/http-routing/#request-parameter-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80.","title":"Request parameter based matching"},{"location":"Use-Cases/http-routing/#multiple-matches-in-a-httproute","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"Multiple matches in a HTTPRoute"},{"location":"Use-Cases/multiple-ns/","text":"Cross-Namespace routing \u00b6 In this scenario, we demonstrate the process of attaching httproute to gateway which might be in a different namespace. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration. Gateway allows Routes from all namespaces \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : All addresses : - value : 10.250.15.2 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-all namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is All , it means this gateway does not care what namespace the routes are from. So although the Gateway and HTTPRoute are from different namespaces above, it does not matter. Gateway allows Routes from the same namespace \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : default labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Same addresses : - value : 10.25.15.3 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-same namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : default hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Same , it means this gateway only allowes routes from the same namespace to attach to it. In the example above, both the gateway and HTTPRoute are from default namespace. Gateway allows Routes from namespaces filtered by namespace selector \u00b6 --- apiVersion : v1 kind : Namespace metadata : name : newlable-ns labels : newlable : \"newlable\" --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Selector selector : matchLabels : newlable : \"newlable\" addresses : - value : 10.25.15.4 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-selector namespace : newlable-ns spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Selector , it means this gateway allows routes from those namespaces that satisfy the namespace selector. In this example, routes whose namespace has label newlable=newlable are allowed to attach to the gateway.","title":"Cross-Namespace Routing"},{"location":"Use-Cases/multiple-ns/#cross-namespace-routing","text":"In this scenario, we demonstrate the process of attaching httproute to gateway which might be in a different namespace. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration.","title":"Cross-Namespace routing"},{"location":"Use-Cases/multiple-ns/#gateway-allows-routes-from-all-namespaces","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : All addresses : - value : 10.250.15.2 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-all namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is All , it means this gateway does not care what namespace the routes are from. So although the Gateway and HTTPRoute are from different namespaces above, it does not matter.","title":"Gateway allows Routes from all namespaces"},{"location":"Use-Cases/multiple-ns/#gateway-allows-routes-from-the-same-namespace","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : default labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Same addresses : - value : 10.25.15.3 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-same namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : default hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Same , it means this gateway only allowes routes from the same namespace to attach to it. In the example above, both the gateway and HTTPRoute are from default namespace.","title":"Gateway allows Routes from the same namespace"},{"location":"Use-Cases/multiple-ns/#gateway-allows-routes-from-namespaces-filtered-by-namespace-selector","text":"--- apiVersion : v1 kind : Namespace metadata : name : newlable-ns labels : newlable : \"newlable\" --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway.nginx.org spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Selector selector : matchLabels : newlable : \"newlable\" addresses : - value : 10.25.15.4 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-selector namespace : newlable-ns spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Selector , it means this gateway allows routes from those namespaces that satisfy the namespace selector. In this example, routes whose namespace has label newlable=newlable are allowed to attach to the gateway.","title":"Gateway allows Routes from namespaces filtered by namespace selector"},{"location":"Use-Cases/service-definition/","text":"The servcie definitions for references only Note that: tea servcie is defined as NodePort and coffee service is ClusterIP . Change it as necessary. tea.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello}; coffee.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"Service definition"},{"location":"Use-Cases/service-definition/#teayaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"tea.yaml"},{"location":"Use-Cases/service-definition/#coffeeyaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"coffee.yaml"},{"location":"Use-Cases/simple-gateway/","text":"Deploying a simple Gateway \u00b6 Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Simple Gateway"},{"location":"Use-Cases/simple-gateway/#deploying-a-simple-gateway","text":"Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Deploying a simple Gateway"},{"location":"Use-Cases/tcp/","text":"TCP routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"TCP Routing"},{"location":"Use-Cases/tcp/#tcp-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"TCP routing"},{"location":"Use-Cases/tls/","text":"TLS Configuration \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"TLS"},{"location":"Use-Cases/tls/#tls-configuration","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"TLS Configuration"},{"location":"Use-Cases/traffic-splitting/","text":"HTTP traffic splitting \u00b6 In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"HTTP Traffic Splitting"},{"location":"Use-Cases/traffic-splitting/#http-traffic-splitting","text":"In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"HTTP traffic splitting"},{"location":"concepts/","text":"Coming soon \u00b6","title":"Overview"},{"location":"concepts/#coming-soon","text":"","title":"Coming soon"},{"location":"concepts/gateway/","text":"Coming soon \u00b6","title":"Gateway"},{"location":"concepts/gateway/#coming-soon","text":"","title":"Coming soon"},{"location":"concepts/gatewayclass/","text":"Coming soon \u00b6","title":"GatewayClass"},{"location":"concepts/gatewayclass/#coming-soon","text":"","title":"Coming soon"},{"location":"concepts/httproute/","text":"Coming soon \u00b6","title":"HTTPRoute"},{"location":"concepts/httproute/#coming-soon","text":"","title":"Coming soon"},{"location":"quick-start/","text":"Get Started \u00b6 You\u2019ll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: bigip-kubernetes-gateway controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster kubectl cluster-info shows). If the controller runs in In-Cluster mode, it will depends on the serviceaccount and role/role-binding described in installation . Kubernetes Setup For Gateway API Integration \u00b6 After you have a K8s cluster, we need to configure it for different CNI types to make sure connection between BIG-IP and kubernetes cluster is OK. Note: To enable Gateway API integration via BIG-IP, actually, we need to configure both sides of BIG-IPs and the Kubernetes cluster, however, the BIG-IP side is configured by controller itself automatically when the controller is started. Here, we only need to configure Kubernetes side manually. For different CNIs, we have different configuration steps as following. In Flannel mode \u00b6 In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node to the Kubernetes. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node. In Calico mode \u00b6 In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"Prerequisites"},{"location":"quick-start/#get-started","text":"You\u2019ll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: bigip-kubernetes-gateway controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster kubectl cluster-info shows). If the controller runs in In-Cluster mode, it will depends on the serviceaccount and role/role-binding described in installation .","title":"Get Started"},{"location":"quick-start/#kubernetes-setup-for-gateway-api-integration","text":"After you have a K8s cluster, we need to configure it for different CNI types to make sure connection between BIG-IP and kubernetes cluster is OK. Note: To enable Gateway API integration via BIG-IP, actually, we need to configure both sides of BIG-IPs and the Kubernetes cluster, however, the BIG-IP side is configured by controller itself automatically when the controller is started. Here, we only need to configure Kubernetes side manually. For different CNIs, we have different configuration steps as following.","title":"Kubernetes Setup For Gateway API Integration"},{"location":"quick-start/#in-flannel-mode","text":"In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node to the Kubernetes. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node.","title":"In Flannel mode"},{"location":"quick-start/#in-calico-mode","text":"In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"In Calico mode"},{"location":"quick-start/installation/","text":"Installation \u00b6 In the code repository , we provide the Gateway API deployment yaml files for installation. The deployment yaml files are located at: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/deploy . The files are numbered and can complete the deployment process in order, where: file name functionality notes 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy bigip-kubernetes-gateway controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster watching CRUD events for gateway-related resources. View deployment results via kubectl get deployment -n kube-system . View the run log via kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters .","title":"Installation Guide"},{"location":"quick-start/installation/#installation","text":"In the code repository , we provide the Gateway API deployment yaml files for installation. The deployment yaml files are located at: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/deploy . The files are numbered and can complete the deployment process in order, where: file name functionality notes 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy bigip-kubernetes-gateway controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster watching CRUD events for gateway-related resources. View deployment results via kubectl get deployment -n kube-system . View the run log via kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters .","title":"Installation"},{"location":"quick-start/parameters/","text":"Parameters \u00b6 The examples of the parameters are available in the deployment yaml file placed on the code repository: deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml . There are 2 parts of BIG-IP configurations: The password of BIG-IP passed in via a Kubernetes Secret(Part 1). Some additional BIG-IP configuration information passed in via a separate Kubernetes Configmap(Part 2). In the controller deployment yaml file(Part 3), the two parts of configurations are passed in the form of volume, and the controller reads the specific configuration content of the indicated paths. Part 1: bigip-login \u00b6 --- apiVersion : v1 kind : Secret metadata : name : bigip-login namespace : kube-system data : password : UEBzc3cwcmQxMjM= # base64 password for admin type : Opaque BIG-IP's password for admin is stored in a separate Secret type resource for security concern. Part 2: bigip-kubernetes-gateway-configmap \u00b6 --- apiVersion : v1 kind : ConfigMap metadata : name : bigip-kubernetes-gateway-configmap namespace : kube-system data : bigip-kubernetes-gateway-config : | - management: username: admin ipAddress: 10.250.15.180 port: 443 flannel: tunnels: - name: fl-tunnel profileName: fl-vxlan port: 8472 localAddress: 10.250.18.119 selfIPs: - name: flannel-self ipMask: 10.42.20.1/16 tunnelName: fl-tunnel calico: localAS: &as 64512 remoteAS: *as Within the above configmap, it stores BIG-IP configuration for network setup and resource managements. The controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are: # BIG-IP management info - management : # username, must be amdin currently username : admin # management IP address for iControl Rest ipAddress : 10.250.15.180 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) localAddress : 10.250.18.119 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # tunnel name, should match one of the tunnels tunnelName : fl-tunnel # optional, underlay network configuration for calico CNI mode calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as Note that, If we don't want to configure BIG-IP in flannel mode, just remove/comment the flannel parts. It's same to calico case. Futher, if we don't want to configure BIG-IP at all, remove/comment both of them, the controller will keep the CNI configurations on BIG-IP as user configure them manually in advance. Part 3: bigip-kubernetes-gateway deployment and service \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : bigip-kubernetes-gateway namespace : kube-system spec : replicas : 1 #... spec : serviceAccountName : k8s-bigip-ctlr nodeSelector : node-role.kubernetes.io/control-plane : \"true\" # node-role.kubernetes.io/master: \"true\" containers : # use `kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system` for tracing. - name : bigip-kubernetes-gateway-pod image : f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 imagePullPolicy : IfNotPresent command : [ \"/bigip-kubernetes-gateway-controller-linux\" ] args : [ \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , ] volumeMounts : - name : bigip-credential mountPath : \"/bigip-credential\" readOnly : true - name : bigip-config mountPath : /bigip-config readOnly : true volumes : - name : bigip-credential secret : secretName : bigip-login - name : bigip-config configMap : name : bigip-kubernetes-gateway-configmap For the yaml file above, let's pay attention to image , args , volumeMounts and volumes parts. For details about the usage of the file, See installation .","title":"Controller Parameters"},{"location":"quick-start/parameters/#parameters","text":"The examples of the parameters are available in the deployment yaml file placed on the code repository: deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml . There are 2 parts of BIG-IP configurations: The password of BIG-IP passed in via a Kubernetes Secret(Part 1). Some additional BIG-IP configuration information passed in via a separate Kubernetes Configmap(Part 2). In the controller deployment yaml file(Part 3), the two parts of configurations are passed in the form of volume, and the controller reads the specific configuration content of the indicated paths.","title":"Parameters"},{"location":"quick-start/parameters/#part-1-bigip-login","text":"--- apiVersion : v1 kind : Secret metadata : name : bigip-login namespace : kube-system data : password : UEBzc3cwcmQxMjM= # base64 password for admin type : Opaque BIG-IP's password for admin is stored in a separate Secret type resource for security concern.","title":"Part 1: bigip-login"},{"location":"quick-start/parameters/#part-2-bigip-kubernetes-gateway-configmap","text":"--- apiVersion : v1 kind : ConfigMap metadata : name : bigip-kubernetes-gateway-configmap namespace : kube-system data : bigip-kubernetes-gateway-config : | - management: username: admin ipAddress: 10.250.15.180 port: 443 flannel: tunnels: - name: fl-tunnel profileName: fl-vxlan port: 8472 localAddress: 10.250.18.119 selfIPs: - name: flannel-self ipMask: 10.42.20.1/16 tunnelName: fl-tunnel calico: localAS: &as 64512 remoteAS: *as Within the above configmap, it stores BIG-IP configuration for network setup and resource managements. The controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are: # BIG-IP management info - management : # username, must be amdin currently username : admin # management IP address for iControl Rest ipAddress : 10.250.15.180 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) localAddress : 10.250.18.119 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # tunnel name, should match one of the tunnels tunnelName : fl-tunnel # optional, underlay network configuration for calico CNI mode calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as Note that, If we don't want to configure BIG-IP in flannel mode, just remove/comment the flannel parts. It's same to calico case. Futher, if we don't want to configure BIG-IP at all, remove/comment both of them, the controller will keep the CNI configurations on BIG-IP as user configure them manually in advance.","title":"Part 2: bigip-kubernetes-gateway-configmap"},{"location":"quick-start/parameters/#part-3-bigip-kubernetes-gateway-deployment-and-service","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : bigip-kubernetes-gateway namespace : kube-system spec : replicas : 1 #... spec : serviceAccountName : k8s-bigip-ctlr nodeSelector : node-role.kubernetes.io/control-plane : \"true\" # node-role.kubernetes.io/master: \"true\" containers : # use `kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system` for tracing. - name : bigip-kubernetes-gateway-pod image : f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 imagePullPolicy : IfNotPresent command : [ \"/bigip-kubernetes-gateway-controller-linux\" ] args : [ \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , ] volumeMounts : - name : bigip-credential mountPath : \"/bigip-credential\" readOnly : true - name : bigip-config mountPath : /bigip-config readOnly : true volumes : - name : bigip-credential secret : secretName : bigip-login - name : bigip-config configMap : name : bigip-kubernetes-gateway-configmap For the yaml file above, let's pay attention to image , args , volumeMounts and volumes parts. For details about the usage of the file, See installation .","title":"Part 3: bigip-kubernetes-gateway deployment and service"},{"location":"quick-start/uninstall/","text":"Uninstallation \u00b6 The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Unstallation Guide"},{"location":"quick-start/uninstall/#uninstallation","text":"The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Uninstallation"}]}