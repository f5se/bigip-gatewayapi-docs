{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\u200b\\-]"},"docs":[{"location":"","text":"F5 BIG-IP Kubernetes GatewayAPI Controller \u00b6 Welcome. This is the online docs of F5 BIG-IP kubernetes GatewayAPI Controller. F5 BIG-IP kubernetes GatewayAPI Controller is an implementation of K8S Gateway API at v0.6.2 . As F5 has two traffic management system, one is the BIG-IP, the other one is the Next-Generation BIG-IP Software. So we have 2 integration as well. According to the context, if we emphasize the 'Next', that means it is only for BIG-IP Next, otherwise they are same for BIG-IP or BIG-IP Next. For a list of supported GatewayAPI resources and features, see the Gateway API Compatibility doc. Check here for Gateway API's latest status. It's open-source and community supported. Source code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway . Welcome to join us, you can get help in the slack channel #oss-bigip-kubernetes-gateway or Wechat . See here for the latest release.","title":"Overview"},{"location":"#f5-big-ip-kubernetes-gatewayapi-controller","text":"Welcome. This is the online docs of F5 BIG-IP kubernetes GatewayAPI Controller. F5 BIG-IP kubernetes GatewayAPI Controller is an implementation of K8S Gateway API at v0.6.2 . As F5 has two traffic management system, one is the BIG-IP, the other one is the Next-Generation BIG-IP Software. So we have 2 integration as well. According to the context, if we emphasize the 'Next', that means it is only for BIG-IP Next, otherwise they are same for BIG-IP or BIG-IP Next. For a list of supported GatewayAPI resources and features, see the Gateway API Compatibility doc. Check here for Gateway API's latest status. It's open-source and community supported. Source code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway . Welcome to join us, you can get help in the slack channel #oss-bigip-kubernetes-gateway or Wechat . See here for the latest release.","title":"F5 BIG-IP Kubernetes GatewayAPI Controller"},{"location":"Design/bip/","text":"Overview \u00b6 BIG-IP Kubernetes GatewayAPI Controller (\"Controller\" in short) is one of GatewayAPI downstream implementations . The Controller is responsible for resolving 2 problems, Automatical application deliveries on downstream BIG-IP instance(s). Network connectivity setup between Kubernetes CNI and BIG-IP(s) traffic network. Resource Monitoring \u00b6 Like all other CRD implementations, the Controller monitors Kubernetes GatewayAPI CRD resources (gateway.networking.k8s.io/v1beta1) and converts them to BIG-IP-related configurations for deploying to BIG-IP devices. The Controller connects to the upstream Kubernetes, monitors Gateway API updating events from the cluster through the list-watch mechanism. The mechanism was encapsulated in client-go (k8s.io/client-go) and controller-runtime (sigs.k8s.io/controller-runtime). In order to access various necessary resources of Kubernetes, we need to use specific ServiceAccount and ClusterRole that have specific permissions. Please refer to installation guide for permission details. Resource Mapping \u00b6 The Controller connects to the downstream BIG-IP to parse, convert and deploy the Gateway API configuration to BIG-IP as ADC resources. The correspondence between GatewayAPI resources and BIG-IP resources is as follows: We can see that, with BIG-IP as a provider, the specific form of each gateway resource on BIG-IP is: K8S Resources BIG-IP Resources Controller BIG-IP Device GatewayClass Partition Gateway Virtual HTTPRoute iRule Service Pool Deploy ( pods ) Member Networking Enablement \u00b6 In term of network connectivity, as we know, Kubernetes has different CNI types, like flannel(overlay), calico(underlay), etc. For overlay network, the Controller setup the tunnel between BIG-IP traffic network and Kubernetes network, also, make the new deployed Service to be discovered(setup the fdb/arp) on BIG-IP, so that the North-south traffic can go through. For underlay network, the Controller setups the BGP neighbors for discoveries to any service deployment. Notes that, all the networking setup should be automatic. The controller is responsible for network enablement along with BIG-IP resources\u2019 deployment. Deploying Methods \u00b6 BIG-IP provides a variety of Configuration Utilities, such as AS3, iControl Rest, tmsh. In Controller, we currently use iControl Rest to assemble the list of deployed resources through transactions, and use incremental way to achieve the deployments, this process is encapsulated as BIG-IP iControl Rest golang module. It is characterized by incremental, fast, self-discovery of BIG-IP resource status. Of course, using AS3 is another possibility. AS3 is F5 recommended way to do ADC deployment to BIG-IP. In the future, AS3 will be the only external configuration utility for BIG-IP Next product. We will continuously check its performance, integrate it into the Controller at the right time and in the right way.","title":"BIG-IP Controller Overview"},{"location":"Design/bip/#overview","text":"BIG-IP Kubernetes GatewayAPI Controller (\"Controller\" in short) is one of GatewayAPI downstream implementations . The Controller is responsible for resolving 2 problems, Automatical application deliveries on downstream BIG-IP instance(s). Network connectivity setup between Kubernetes CNI and BIG-IP(s) traffic network.","title":"Overview"},{"location":"Design/bip/#resource-monitoring","text":"Like all other CRD implementations, the Controller monitors Kubernetes GatewayAPI CRD resources (gateway.networking.k8s.io/v1beta1) and converts them to BIG-IP-related configurations for deploying to BIG-IP devices. The Controller connects to the upstream Kubernetes, monitors Gateway API updating events from the cluster through the list-watch mechanism. The mechanism was encapsulated in client-go (k8s.io/client-go) and controller-runtime (sigs.k8s.io/controller-runtime). In order to access various necessary resources of Kubernetes, we need to use specific ServiceAccount and ClusterRole that have specific permissions. Please refer to installation guide for permission details.","title":"Resource Monitoring"},{"location":"Design/bip/#resource-mapping","text":"The Controller connects to the downstream BIG-IP to parse, convert and deploy the Gateway API configuration to BIG-IP as ADC resources. The correspondence between GatewayAPI resources and BIG-IP resources is as follows: We can see that, with BIG-IP as a provider, the specific form of each gateway resource on BIG-IP is: K8S Resources BIG-IP Resources Controller BIG-IP Device GatewayClass Partition Gateway Virtual HTTPRoute iRule Service Pool Deploy ( pods ) Member","title":"Resource Mapping"},{"location":"Design/bip/#networking-enablement","text":"In term of network connectivity, as we know, Kubernetes has different CNI types, like flannel(overlay), calico(underlay), etc. For overlay network, the Controller setup the tunnel between BIG-IP traffic network and Kubernetes network, also, make the new deployed Service to be discovered(setup the fdb/arp) on BIG-IP, so that the North-south traffic can go through. For underlay network, the Controller setups the BGP neighbors for discoveries to any service deployment. Notes that, all the networking setup should be automatic. The controller is responsible for network enablement along with BIG-IP resources\u2019 deployment.","title":"Networking Enablement"},{"location":"Design/bip/#deploying-methods","text":"BIG-IP provides a variety of Configuration Utilities, such as AS3, iControl Rest, tmsh. In Controller, we currently use iControl Rest to assemble the list of deployed resources through transactions, and use incremental way to achieve the deployments, this process is encapsulated as BIG-IP iControl Rest golang module. It is characterized by incremental, fast, self-discovery of BIG-IP resource status. Of course, using AS3 is another possibility. AS3 is F5 recommended way to do ADC deployment to BIG-IP. In the future, AS3 will be the only external configuration utility for BIG-IP Next product. We will continuously check its performance, integrate it into the Controller at the right time and in the right way.","title":"Deploying Methods"},{"location":"Design/bipnext/","text":"Overview [WIP] \u00b6 What is BIG-IP Next \u00b6 At its core, it\u2019s still the same BIG-IP that F5 customers know and trust, simply designed and rearchitected for the future. BIG-IP Next is the next generation BIG-IP software built to offer greater automation opportunities, scalability, and ease-of-use for organizations running applications on-premises, in the cloud, or out at the edge. Powerful declarative APIs are the foundation for BIG-IP Next\u2019s API-first design, making it faster and easier for DevOps, NetOps, and other BIG-IP-reliant teams to manage and automate their BIG-IP deployments. A completely rearchitected software layer built on a modern framework provides the basis for significantly improved control plane scale and performance, reduced cloud footprint for lower operational costs, and rapid instance upgrades. Carrying forward the comprehensive suite of advanced BIG-IP functionality developed over the past 20 years, BIG-IP Next continues to deliver everything from application security and access controls to local and global traffic management\u2014and availability across the same breadth of deployment and consumption models as its predecessor. What is BIG-IP Next Kubernetes GatewayAPI Controller \u00b6 BIG-IP Next Kubernetes GatewayAPI Controller (\"Controller next\" in short) is one of GatewayAPI downstream implementations . The \"Controller Next\" is responsible for resolving 2 problems, Automatical application deliveries on downstream BIG-IP Next instance(s). Network connectivity setup between Kubernetes CNI and BIG-IP Next(s) traffic network. Resource Monitoring \u00b6 Like all other CRD implementations, the Controller monitors Kubernetes GatewayAPI CRD resources (gateway.networking.k8s.io/v1beta1) and converts them to BIG-IP Next-related configurations for deploying to BIG-IP Next devices. The Controller connects to the upstream Kubernetes, monitors Gateway API updating events from the cluster through the list-watch mechanism. The mechanism was encapsulated in client-go (k8s.io/client-go) and controller-runtime (sigs.k8s.io/controller-runtime). In order to access various necessary resources of Kubernetes, we need to use specific ServiceAccount and ClusterRole that have specific permissions. Please refer to installation guide for permission details. Resource Mapping \u00b6 TODO We are actively work on the integration of BIG-IP Next, will update. If you want to learn what is BIG-IP Next, kindly please click here .","title":"BIG-IP Next Controller Overview"},{"location":"Design/bipnext/#overview-wip","text":"","title":"Overview [WIP]"},{"location":"Design/bipnext/#what-is-big-ip-next","text":"At its core, it\u2019s still the same BIG-IP that F5 customers know and trust, simply designed and rearchitected for the future. BIG-IP Next is the next generation BIG-IP software built to offer greater automation opportunities, scalability, and ease-of-use for organizations running applications on-premises, in the cloud, or out at the edge. Powerful declarative APIs are the foundation for BIG-IP Next\u2019s API-first design, making it faster and easier for DevOps, NetOps, and other BIG-IP-reliant teams to manage and automate their BIG-IP deployments. A completely rearchitected software layer built on a modern framework provides the basis for significantly improved control plane scale and performance, reduced cloud footprint for lower operational costs, and rapid instance upgrades. Carrying forward the comprehensive suite of advanced BIG-IP functionality developed over the past 20 years, BIG-IP Next continues to deliver everything from application security and access controls to local and global traffic management\u2014and availability across the same breadth of deployment and consumption models as its predecessor.","title":"What is BIG-IP Next"},{"location":"Design/bipnext/#what-is-big-ip-next-kubernetes-gatewayapi-controller","text":"BIG-IP Next Kubernetes GatewayAPI Controller (\"Controller next\" in short) is one of GatewayAPI downstream implementations . The \"Controller Next\" is responsible for resolving 2 problems, Automatical application deliveries on downstream BIG-IP Next instance(s). Network connectivity setup between Kubernetes CNI and BIG-IP Next(s) traffic network.","title":"What is BIG-IP Next Kubernetes GatewayAPI Controller"},{"location":"Design/bipnext/#resource-monitoring","text":"Like all other CRD implementations, the Controller monitors Kubernetes GatewayAPI CRD resources (gateway.networking.k8s.io/v1beta1) and converts them to BIG-IP Next-related configurations for deploying to BIG-IP Next devices. The Controller connects to the upstream Kubernetes, monitors Gateway API updating events from the cluster through the list-watch mechanism. The mechanism was encapsulated in client-go (k8s.io/client-go) and controller-runtime (sigs.k8s.io/controller-runtime). In order to access various necessary resources of Kubernetes, we need to use specific ServiceAccount and ClusterRole that have specific permissions. Please refer to installation guide for permission details.","title":"Resource Monitoring"},{"location":"Design/bipnext/#resource-mapping","text":"TODO We are actively work on the integration of BIG-IP Next, will update. If you want to learn what is BIG-IP Next, kindly please click here .","title":"Resource Mapping"},{"location":"Operation-and-troubleshooting/ki/","text":"Known Issues \u00b6 No issue yet. Please report your issue or suggestion on https://github.com/f5devcentral/bigip-kubernetes-gateway/issues .","title":"Common FAQ"},{"location":"Operation-and-troubleshooting/ki/#known-issues","text":"No issue yet. Please report your issue or suggestion on https://github.com/f5devcentral/bigip-kubernetes-gateway/issues .","title":"Known Issues"},{"location":"Operation-and-troubleshooting/trubeshooting/","text":"Trouble Shooting \u00b6 Use the following command to trace or detect any issue: $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system Will continously complement this section in the future.","title":"Troubleshooting"},{"location":"Operation-and-troubleshooting/trubeshooting/#trouble-shooting","text":"Use the following command to trace or detect any issue: $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system Will continously complement this section in the future.","title":"Trouble Shooting"},{"location":"Release-notes/","text":"Releases \u00b6 The bigip-kubernetes-gateway versions are released on dockerhub as Docker images . The code repository is f5devcentral/bigip-kubernetes-gateway . Release v0.2.1 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.2.1-20230411 Reference: \u00b6 https://gateway-api.f5se.io/guides/getstarted Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Add support for log levels instead of all \"debug\" by @zongzw in #26 Add runtime dumps abiliity. by @zongzw in #32 Enhance devops with adding dumping and trailing support. by @zongzw in #33 Separate cni setup logic to standalone tool: f5-tool-setup-cni by @zongzw in #34 Change the mod from gitee to github by @zhang-shengping in #38 Add system test framework by @zongzw in #40 Refine the codes to standard project layout. by @zongzw in #44 Basic ginkgo test for tls gateway by @zhang-shengping in #45 , #48 , #49 Feature Support \u00b6 Add cross namespace routing support. by @zongzw in #23 , #24 Implement responseHeaderModifier by @zongzw in #28 Add ReferenceGrant support. by @zongzw in #30 Use template for irule generation. by @zhang-shengping in #32 Add https function for gateway. by @zhang-shengping in #35 Use referencegrant for secret cross-reference restriction. by @zongzw in #36 Add webhook framework and automation yamls. by @zongzw @zhang-shengping in #37 , #41 , #42 Bugfix: avoid deploying resources of other controllerName. by @zongzw in #43 Documentation Support \u00b6 Update compatibility docs; add more spec support. by @zongzw in #21 Add gateway controller examples by @zongzw in #46 Release v0.2.0 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.2.0-20230216 Reference: \u00b6 https://gateway-api.f5se.io/guides/getstarted Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Refine logging with given log level and tracing request id. Feature Support \u00b6 Fix startup's bigip password issue ( PR ) Fix sig.k8s.io/controller-runtime dependency issue( PR ). Be compatible with sig gateway api v0.6.0 specification. Add support for HTTPRoute.Filter.ResponseHeaderModifier. Add support for ReferenceGrant for service binding restriction. Documentation Support \u00b6 Update compatibility document for ReferenceGrant and responseHeaderModifier support. Release v0.1.1 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.1.1-20230111 Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Refine conroller's logging Feature Support \u00b6 Add Support for Gateway.Listener.AllowedRouted Spec. See more details from the PR and the Usecase Add AS configuration for calico mode. Documentation Support \u00b6 Update compatibility docs Release v0.1.0 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.1.0-20221226 Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Supports full DevOps capabilities, providing all YAML files for installation and deployment. Uses github action for the integration with Slack . Feature Support \u00b6 Supports using configmap as the controller's parameter format Supports the ability to deliver and configure resources to BIG-IP, refer to gateway api compatibility , also, refer to all usecases . Supports integration with Prometheus to capture controller performance data. Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks. Supports log tracing with request id. Supports automated configuration of flannel and calico CNI modes on the BIG-IP side. Documentation Support \u00b6 Documentation on https://gateway-api.f5se.io/ . Release v0.0.4 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 Improve the automated configuration of the BIG-IP side in flannel and calico modes, see here Determine the parameters passed in by the user, see here Fixed the partition deletion issue when the gatewayclass was deleted, see here Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.3...v0.0.4 Release v0.0.3 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.3-20221213 Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 Documentation on https://gateway-api.f5se.io/ , including: Update usage of deploy/install controller Add gateway api compatibility reference Add LICENSE declaration Use github action for the integration with Slack. Redesign gatewayclass and controller relationship that moves BIG-IP configuration to controller level. Add controller parameter form of configmap . Add BIG-IP configuration ability for flannel and calico CNIs( here ). Enable log tracing with request id. Implement httproute traffic splitting feature ( here ). Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.2...v0.0.3 Release v0.0.2 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.2-20221129 Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 Add support for gatewayclass resources, see gatewayclass design . Implement the ability of handling disorder events for kinds of resources. Improve the design and usage documentation: https://gateway-api.f5se.io/ Optimize the resource synchronization mode at startup time for deployment integrity. Update the f5-bigip-rest dependency for better deployments. Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.1...v0.0.2 Release v0.0.1 \u00b6 Docker Image: \u00b6 f5devcentral/bigip-kubernetes-gateway:v0.0.1-20221115 Deployment Reference: \u00b6 https://gateway-api.f5se.io/deploy/installation/ Release Notes: \u00b6 DevOps and Monitoring Support \u00b6 Supports full DevOps capabilities, providing all YAML files for installation and deployment. Supports integration with Prometheus to capture controller performance data Basic automated testing capabilities. Feature Support \u00b6 Supports the ability to deliver and configure resources: gateway httproute and service deployment, to BIG-IP. Supports resource specs: gatewayclass: not support gateway\uff1a listeners\uff1aname port protocol addresses\uff1avalue httproute parentRefs hostnames rules matches: method header path queryParams filters: RequestHeaderModifier RequestRedirect ExtensionRef backendRefs: partial, only one backend supported Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks.","title":"Releases"},{"location":"Release-notes/#releases","text":"The bigip-kubernetes-gateway versions are released on dockerhub as Docker images . The code repository is f5devcentral/bigip-kubernetes-gateway .","title":"Releases"},{"location":"Release-notes/#release-v021","text":"","title":"Release v0.2.1"},{"location":"Release-notes/#docker-image","text":"f5devcentral/bigip-kubernetes-gateway:v0.2.1-20230411","title":"Docker Image:"},{"location":"Release-notes/#reference","text":"https://gateway-api.f5se.io/guides/getstarted","title":"Reference:"},{"location":"Release-notes/#release-notes","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support","text":"Add support for log levels instead of all \"debug\" by @zongzw in #26 Add runtime dumps abiliity. by @zongzw in #32 Enhance devops with adding dumping and trailing support. by @zongzw in #33 Separate cni setup logic to standalone tool: f5-tool-setup-cni by @zongzw in #34 Change the mod from gitee to github by @zhang-shengping in #38 Add system test framework by @zongzw in #40 Refine the codes to standard project layout. by @zongzw in #44 Basic ginkgo test for tls gateway by @zhang-shengping in #45 , #48 , #49","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support","text":"Add cross namespace routing support. by @zongzw in #23 , #24 Implement responseHeaderModifier by @zongzw in #28 Add ReferenceGrant support. by @zongzw in #30 Use template for irule generation. by @zhang-shengping in #32 Add https function for gateway. by @zhang-shengping in #35 Use referencegrant for secret cross-reference restriction. by @zongzw in #36 Add webhook framework and automation yamls. by @zongzw @zhang-shengping in #37 , #41 , #42 Bugfix: avoid deploying resources of other controllerName. by @zongzw in #43","title":"Feature Support"},{"location":"Release-notes/#documentation-support","text":"Update compatibility docs; add more spec support. by @zongzw in #21 Add gateway controller examples by @zongzw in #46","title":"Documentation Support"},{"location":"Release-notes/#release-v020","text":"","title":"Release v0.2.0"},{"location":"Release-notes/#docker-image_1","text":"f5devcentral/bigip-kubernetes-gateway:v0.2.0-20230216","title":"Docker Image:"},{"location":"Release-notes/#reference_1","text":"https://gateway-api.f5se.io/guides/getstarted","title":"Reference:"},{"location":"Release-notes/#release-notes_1","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_1","text":"Refine logging with given log level and tracing request id.","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_1","text":"Fix startup's bigip password issue ( PR ) Fix sig.k8s.io/controller-runtime dependency issue( PR ). Be compatible with sig gateway api v0.6.0 specification. Add support for HTTPRoute.Filter.ResponseHeaderModifier. Add support for ReferenceGrant for service binding restriction.","title":"Feature Support"},{"location":"Release-notes/#documentation-support_1","text":"Update compatibility document for ReferenceGrant and responseHeaderModifier support.","title":"Documentation Support"},{"location":"Release-notes/#release-v011","text":"","title":"Release v0.1.1"},{"location":"Release-notes/#docker-image_2","text":"f5devcentral/bigip-kubernetes-gateway:v0.1.1-20230111","title":"Docker Image:"},{"location":"Release-notes/#reference_2","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_2","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_2","text":"Refine conroller's logging","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_2","text":"Add Support for Gateway.Listener.AllowedRouted Spec. See more details from the PR and the Usecase Add AS configuration for calico mode.","title":"Feature Support"},{"location":"Release-notes/#documentation-support_2","text":"Update compatibility docs","title":"Documentation Support"},{"location":"Release-notes/#release-v010","text":"","title":"Release v0.1.0"},{"location":"Release-notes/#docker-image_3","text":"f5devcentral/bigip-kubernetes-gateway:v0.1.0-20221226","title":"Docker Image:"},{"location":"Release-notes/#reference_3","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_3","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_3","text":"Supports full DevOps capabilities, providing all YAML files for installation and deployment. Uses github action for the integration with Slack .","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_3","text":"Supports using configmap as the controller's parameter format Supports the ability to deliver and configure resources to BIG-IP, refer to gateway api compatibility , also, refer to all usecases . Supports integration with Prometheus to capture controller performance data. Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks. Supports log tracing with request id. Supports automated configuration of flannel and calico CNI modes on the BIG-IP side.","title":"Feature Support"},{"location":"Release-notes/#documentation-support_3","text":"Documentation on https://gateway-api.f5se.io/ .","title":"Documentation Support"},{"location":"Release-notes/#release-v004","text":"","title":"Release v0.0.4"},{"location":"Release-notes/#docker-image_4","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219","title":"Docker Image:"},{"location":"Release-notes/#reference_4","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_4","text":"Improve the automated configuration of the BIG-IP side in flannel and calico modes, see here Determine the parameters passed in by the user, see here Fixed the partition deletion issue when the gatewayclass was deleted, see here Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.3...v0.0.4","title":"Release Notes:"},{"location":"Release-notes/#release-v003","text":"","title":"Release v0.0.3"},{"location":"Release-notes/#docker-image_5","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.3-20221213","title":"Docker Image:"},{"location":"Release-notes/#reference_5","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_5","text":"Documentation on https://gateway-api.f5se.io/ , including: Update usage of deploy/install controller Add gateway api compatibility reference Add LICENSE declaration Use github action for the integration with Slack. Redesign gatewayclass and controller relationship that moves BIG-IP configuration to controller level. Add controller parameter form of configmap . Add BIG-IP configuration ability for flannel and calico CNIs( here ). Enable log tracing with request id. Implement httproute traffic splitting feature ( here ). Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.2...v0.0.3","title":"Release Notes:"},{"location":"Release-notes/#release-v002","text":"","title":"Release v0.0.2"},{"location":"Release-notes/#docker-image_6","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.2-20221129","title":"Docker Image:"},{"location":"Release-notes/#reference_6","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Reference:"},{"location":"Release-notes/#release-notes_6","text":"Add support for gatewayclass resources, see gatewayclass design . Implement the ability of handling disorder events for kinds of resources. Improve the design and usage documentation: https://gateway-api.f5se.io/ Optimize the resource synchronization mode at startup time for deployment integrity. Update the f5-bigip-rest dependency for better deployments. Full Changelog : https://github.com/f5devcentral/bigip-kubernetes-gateway/compare/v0.0.1...v0.0.2","title":"Release Notes:"},{"location":"Release-notes/#release-v001","text":"","title":"Release v0.0.1"},{"location":"Release-notes/#docker-image_7","text":"f5devcentral/bigip-kubernetes-gateway:v0.0.1-20221115","title":"Docker Image:"},{"location":"Release-notes/#deployment-reference","text":"https://gateway-api.f5se.io/deploy/installation/","title":"Deployment Reference:"},{"location":"Release-notes/#release-notes_7","text":"","title":"Release Notes:"},{"location":"Release-notes/#devops-and-monitoring-support_4","text":"Supports full DevOps capabilities, providing all YAML files for installation and deployment. Supports integration with Prometheus to capture controller performance data Basic automated testing capabilities.","title":"DevOps and Monitoring Support"},{"location":"Release-notes/#feature-support_4","text":"Supports the ability to deliver and configure resources: gateway httproute and service deployment, to BIG-IP. Supports resource specs: gatewayclass: not support gateway\uff1a listeners\uff1aname port protocol addresses\uff1avalue httproute parentRefs hostnames rules matches: method header path queryParams filters: RequestHeaderModifier RequestRedirect ExtensionRef backendRefs: partial, only one backend supported Supports service types: NodePort ClusterIP. Supports for CNI flannel and calico networks.","title":"Feature Support"},{"location":"Support-and-contact/","text":"Support and contact \u00b6 For the gateway controller support: \u00b6 Please ask questions or open issues on github Issues For the online docs support: \u00b6 Please ask questions or open issues on github Issues Welcome to contact us by below ways: \u00b6 Slack channel (for global users) Join the f5CloudSolutions Slack workspace first. After joining in the workspace, login into the workspace, find channel #oss-bigip-kubernetes-gateway and join it. Wechat group (for China Wechat users only) zongzw","title":"Tech Support"},{"location":"Support-and-contact/#support-and-contact","text":"","title":"Support and contact"},{"location":"Support-and-contact/#for-the-gateway-controller-support","text":"Please ask questions or open issues on github Issues","title":"For the gateway controller support:"},{"location":"Support-and-contact/#for-the-online-docs-support","text":"Please ask questions or open issues on github Issues","title":"For the online docs support:"},{"location":"Support-and-contact/#welcome-to-contact-us-by-below-ways","text":"Slack channel (for global users) Join the f5CloudSolutions Slack workspace first. After joining in the workspace, login into the workspace, find channel #oss-bigip-kubernetes-gateway and join it. Wechat group (for China Wechat users only) zongzw","title":"Welcome to contact us by below ways:"},{"location":"Support-and-contact/contributions/","text":"Wecome any contributions \u00b6 For online docs, kindly please PR to docs repository For coding contribution kindly please refer the guide in the code repository . Here are the contributors for now\uff1a zongzw f5zong Niklaus-xie Pzhang myf5 Jing Lin License \u00b6 Copyright 2022. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Contributions"},{"location":"Support-and-contact/contributions/#wecome-any-contributions","text":"For online docs, kindly please PR to docs repository For coding contribution kindly please refer the guide in the code repository . Here are the contributors for now\uff1a zongzw f5zong Niklaus-xie Pzhang myf5 Jing Lin","title":"Wecome any contributions"},{"location":"Support-and-contact/contributions/#license","text":"Copyright 2022. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"Use-Cases/grpc-routing/","text":"gRPC routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"Grpc routing"},{"location":"Use-Cases/grpc-routing/#grpc-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"gRPC routing"},{"location":"Use-Cases/http-redirect-rewrite/","text":"HTTP path redirects and rewrites \u00b6 HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Redirects \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently . Rewrites \u00b6 Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"Http redirect rewrite"},{"location":"Use-Cases/http-redirect-rewrite/#http-path-redirects-and-rewrites","text":"HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP path redirects and rewrites"},{"location":"Use-Cases/http-redirect-rewrite/#redirects","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently .","title":"Redirects"},{"location":"Use-Cases/http-redirect-rewrite/#rewrites","text":"Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"Rewrites"},{"location":"Use-Cases/http-routing/","text":"HTTP Routing \u00b6 In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Request header based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80. Request method based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80. Request path based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80. Request parameter based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80. Multiple matches in a HTTPRoute \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"Http routing"},{"location":"Use-Cases/http-routing/#http-routing","text":"In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP Routing"},{"location":"Use-Cases/http-routing/#request-header-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80.","title":"Request header based matching"},{"location":"Use-Cases/http-routing/#request-method-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80.","title":"Request method based matching"},{"location":"Use-Cases/http-routing/#request-path-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80.","title":"Request path based matching"},{"location":"Use-Cases/http-routing/#request-parameter-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80.","title":"Request parameter based matching"},{"location":"Use-Cases/http-routing/#multiple-matches-in-a-httproute","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"Multiple matches in a HTTPRoute"},{"location":"Use-Cases/multiple-ns/","text":"Cross-Namespace routing \u00b6 Supported from bigip-kubernetes-gateway v0.0.5.","title":"Multiple ns"},{"location":"Use-Cases/multiple-ns/#cross-namespace-routing","text":"Supported from bigip-kubernetes-gateway v0.0.5.","title":"Cross-Namespace routing"},{"location":"Use-Cases/service-definition/","text":"The servcie definitions for references only Note that: tea servcie is defined as NodePort and coffee service is ClusterIP . Change it as necessary. tea.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello}; coffee.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"Service definition"},{"location":"Use-Cases/service-definition/#teayaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"tea.yaml"},{"location":"Use-Cases/service-definition/#coffeeyaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"coffee.yaml"},{"location":"Use-Cases/simple-gateway/","text":"Deploying a simple Gateway \u00b6 Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Simple gateway"},{"location":"Use-Cases/simple-gateway/#deploying-a-simple-gateway","text":"Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Deploying a simple Gateway"},{"location":"Use-Cases/tcp/","text":"TCP routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"Tcp"},{"location":"Use-Cases/tcp/#tcp-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"TCP routing"},{"location":"Use-Cases/tls/","text":"TLS Configuration \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"Tls"},{"location":"Use-Cases/tls/#tls-configuration","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"TLS Configuration"},{"location":"Use-Cases/traffic-splitting/","text":"HTTP traffic splitting \u00b6 In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"Traffic splitting"},{"location":"Use-Cases/traffic-splitting/#http-traffic-splitting","text":"In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"HTTP traffic splitting"},{"location":"concepts/","text":"What is the Gateway API? \u00b6 Gateway API is an open source project managed by the SIG-NETWORK community. It is a collection of resources that model service networking in Kubernetes. These resources - GatewayClass,Gateway, HTTPRoute, TCPRoute, Service, etc - aim to evolve Kubernetes service networking through expressive, extensible, and role-oriented interfaces that are implemented by many vendors and have broad industry support GatewayClasses \u00b6 GatewayClasses formalize types of load balancing implementations. These classes make it easy and explicit for users to understand what kind of capabilities are available via the Kubernetes resource model. Shared Gateways and cross-Namespace support \u00b6 They allow the sharing of load balancers and VIPs by permitting independent Route resources to attach to the same Gateway. This allows teams (even across Namespaces) to share infrastructure safely without direct coordination. Typed Routes and typed backends \u00b6 The Gateway API supports typed Route resources and different types of backends. This allows the API to be flexible in supporting various protocols (like HTTP and gRPC) and various backend targets (like Kubernetes Services, storage buckets, or functions).","title":"Overview"},{"location":"concepts/#what-is-the-gateway-api","text":"Gateway API is an open source project managed by the SIG-NETWORK community. It is a collection of resources that model service networking in Kubernetes. These resources - GatewayClass,Gateway, HTTPRoute, TCPRoute, Service, etc - aim to evolve Kubernetes service networking through expressive, extensible, and role-oriented interfaces that are implemented by many vendors and have broad industry support","title":"What is the Gateway API?"},{"location":"concepts/#gatewayclasses","text":"GatewayClasses formalize types of load balancing implementations. These classes make it easy and explicit for users to understand what kind of capabilities are available via the Kubernetes resource model.","title":"GatewayClasses"},{"location":"concepts/#shared-gateways-and-cross-namespace-support","text":"They allow the sharing of load balancers and VIPs by permitting independent Route resources to attach to the same Gateway. This allows teams (even across Namespaces) to share infrastructure safely without direct coordination.","title":"Shared Gateways and cross-Namespace support"},{"location":"concepts/#typed-routes-and-typed-backends","text":"The Gateway API supports typed Route resources and different types of backends. This allows the API to be flexible in supporting various protocols (like HTTP and gRPC) and various backend targets (like Kubernetes Services, storage buckets, or functions).","title":"Typed Routes and typed backends"},{"location":"concepts/gateway/","text":"Gateway \u00b6 A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Service by a cloud load balancer, an in-cluster proxy, or an external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource may be created by an operator directly, or may be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway may be attached to one or more Route references which serve to direct traffic for a subset of traffic to a specific service.","title":"Gateway"},{"location":"concepts/gateway/#gateway","text":"A Gateway describes how traffic can be translated to Services within the cluster. That is, it defines a request for a way to translate traffic from somewhere that does not know about Kubernetes to somewhere that does. For example, traffic sent to a Kubernetes Service by a cloud load balancer, an in-cluster proxy, or an external hardware load balancer. While many use cases have client traffic originating \u201coutside\u201d the cluster, this is not a requirement. It defines a request for a specific load balancer config that implements the GatewayClass\u2019 configuration and behaviour contract. The resource may be created by an operator directly, or may be created by a controller handling a GatewayClass. As the Gateway spec captures user intent, it may not contain a complete specification for all attributes in the spec. For example, the user may omit fields such as addresses, TLS settings. This allows the controller managing the GatewayClass to provide these settings for the user, resulting in a more portable spec. This behaviour will be made clear using the GatewayClass Status object. A Gateway may be attached to one or more Route references which serve to direct traffic for a subset of traffic to a specific service.","title":"Gateway"},{"location":"concepts/gatewayclass/","text":"GatewayClass \u00b6 GatewayClass defines a set of Gateways that share a common configuration and behavior. Each GatewayClass will be handled by a single controller, although controllers may handle more than one GatewayClass. GatewayClass is a cluster-scoped resource. There must be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object.","title":"GatewayClass"},{"location":"concepts/gatewayclass/#gatewayclass","text":"GatewayClass defines a set of Gateways that share a common configuration and behavior. Each GatewayClass will be handled by a single controller, although controllers may handle more than one GatewayClass. GatewayClass is a cluster-scoped resource. There must be at least one GatewayClass defined in order to be able to have functional Gateways. A controller that implements the Gateway API does so by providing an associated GatewayClass resource that the user can reference from their Gateway(s). This is similar to IngressClass for Ingress and StorageClass for PersistentVolumes. In Ingress v1beta1, the closest analog to GatewayClass is the ingress-class annotation, and in IngressV1, the closest analog is the IngressClass object.","title":"GatewayClass"},{"location":"concepts/httproute/","text":"Route Resources \u00b6 Route resources define protocol-specific rules for mapping requests from a Gateway to Kubernetes Services. As of 0.5.1, four Route resource types are included with the API. Custom Route types that are implementation-specific are encouraged for other protocols. New route types may be added to the API in future. HTTPRoute \u00b6 HTTPRoute is for multiplexing HTTP or terminated HTTPS connections. It's intended for use in cases where you want to inspect the HTTP stream and use HTTP request data for either routing or modification, for example using HTTP Headers for routing, or modifying them in-flight. Route summary table \u00b6 The \"Routing Discriminator\" column below refers to what information can be used to allow multiple Routes to share ports on the Listener. Object OSI Layer Routing Discriminator TLS Support Purpose HTTPRoute Layer 7 Anything in the HTTP Protocol Terminated only HTTP and HTTPS Routing TLSRoute Somewhere between layer 4 and 7 SNI or other TLS properties Passthrough or Terminated Routing of TLS protocols including HTTPS where inspection of the HTTP stream is not required. TCPRoute Layer 4 destination port Passthrough or Terminated Allows for forwarding of a TCP stream from the Listener to the Backends UDPRoute Layer 4 destination port None Allows for forwarding of a UDP stream from the Listener to the Backends. GRPCRoute Layer 7 Anything in the gRPC Protocol Terminated only gRPC Routing over HTTP/2 and HTTP/2 cleartext When a Route attaches to a Gateway, it represents configuration that is applied on the Gateway that configures the underlying load balancer or proxy. How and which Routes attach to Gateways is controlled by the resources themselves. Route and Gateway resources have built-in controls to permit or constrain how they are attached. Together with Kubernetes RBAC, these allow organizations to enforce policies for how Routes are exposed and on which Gateways. There is a lot of flexibility in how Routes can attach to Gateways to achieve different organizational policies and scopes of responsibility. These are different relationships that Gateways and Routes can have: \u2022 One-to-one - A Gateway and Route may be deployed and used by a single owner and have a one-to-one relationship. \u2022 One-to-many - A Gateway can have many Routes bound to it that are owned by different teams from across different Namespaces. \u2022 Many-to-one - Routes can also be bound to more than one Gateway, allowing a single Route to control application exposure simultaneously across different IPs, load balancers, or networks. Example A Kubernetes cluster admin has deployed a Gateway shared-gw in the Infra Namespace to be used by different application teams for exposing their applications outside the cluster. Teams A and B (in Namespaces A and B respectively) attach their Routes to this Gateway. They are unaware of each other and as long as their Route rules do not conflict with each other they can continue operating in isolation. Team C has special networking needs (perhaps performance, security, or criticality) and they need a dedicated Gateway to proxy their application to the outside world. Team C deploys their own Gateway dedicated-gw in the C Namespace that can only be used by apps in the C Namespace.","title":"HTTPRoute"},{"location":"concepts/httproute/#route-resources","text":"Route resources define protocol-specific rules for mapping requests from a Gateway to Kubernetes Services. As of 0.5.1, four Route resource types are included with the API. Custom Route types that are implementation-specific are encouraged for other protocols. New route types may be added to the API in future.","title":"Route Resources"},{"location":"concepts/httproute/#httproute","text":"HTTPRoute is for multiplexing HTTP or terminated HTTPS connections. It's intended for use in cases where you want to inspect the HTTP stream and use HTTP request data for either routing or modification, for example using HTTP Headers for routing, or modifying them in-flight.","title":"HTTPRoute"},{"location":"concepts/httproute/#route-summary-table","text":"The \"Routing Discriminator\" column below refers to what information can be used to allow multiple Routes to share ports on the Listener. Object OSI Layer Routing Discriminator TLS Support Purpose HTTPRoute Layer 7 Anything in the HTTP Protocol Terminated only HTTP and HTTPS Routing TLSRoute Somewhere between layer 4 and 7 SNI or other TLS properties Passthrough or Terminated Routing of TLS protocols including HTTPS where inspection of the HTTP stream is not required. TCPRoute Layer 4 destination port Passthrough or Terminated Allows for forwarding of a TCP stream from the Listener to the Backends UDPRoute Layer 4 destination port None Allows for forwarding of a UDP stream from the Listener to the Backends. GRPCRoute Layer 7 Anything in the gRPC Protocol Terminated only gRPC Routing over HTTP/2 and HTTP/2 cleartext When a Route attaches to a Gateway, it represents configuration that is applied on the Gateway that configures the underlying load balancer or proxy. How and which Routes attach to Gateways is controlled by the resources themselves. Route and Gateway resources have built-in controls to permit or constrain how they are attached. Together with Kubernetes RBAC, these allow organizations to enforce policies for how Routes are exposed and on which Gateways. There is a lot of flexibility in how Routes can attach to Gateways to achieve different organizational policies and scopes of responsibility. These are different relationships that Gateways and Routes can have: \u2022 One-to-one - A Gateway and Route may be deployed and used by a single owner and have a one-to-one relationship. \u2022 One-to-many - A Gateway can have many Routes bound to it that are owned by different teams from across different Namespaces. \u2022 Many-to-one - Routes can also be bound to more than one Gateway, allowing a single Route to control application exposure simultaneously across different IPs, load balancers, or networks. Example A Kubernetes cluster admin has deployed a Gateway shared-gw in the Infra Namespace to be used by different application teams for exposing their applications outside the cluster. Teams A and B (in Namespaces A and B respectively) attach their Routes to this Gateway. They are unaware of each other and as long as their Route rules do not conflict with each other they can continue operating in isolation. Team C has special networking needs (perhaps performance, security, or criticality) and they need a dedicated Gateway to proxy their application to the outside world. Team C deploys their own Gateway dedicated-gw in the C Namespace that can only be used by apps in the C Namespace.","title":"Route summary table"},{"location":"concepts/rbac/","text":"RBAC \u00b6 RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model. Write Permissions for Simple 3 Tier Model \u00b6 GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators No Yes Yes Application Developers No No Yes","title":"RBAC"},{"location":"concepts/rbac/#rbac","text":"RBAC (role-based access control) is the standard used for Kubernetes authorization. This allows users to configure who can perform actions on resources in specific scopes. RBAC can be used to enable each of the roles defined above. In most cases, it will be desirable to have all resources be readable by most roles, so instead we'll focus on write access for this model.","title":"RBAC"},{"location":"concepts/rbac/#write-permissions-for-simple-3-tier-model","text":"GatewayClass Gateway Route Infrastructure Provider Yes Yes Yes Cluster Operators No Yes Yes Application Developers No No Yes","title":"Write Permissions for Simple 3 Tier Model"},{"location":"concepts/rolespersonas/","text":"Roles and personas \u00b6 In the original design of Kubernetes, Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. Gateway API is designed to target the following personas: Infrastructure provider: The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...) or the PaaS provider in a company. Cluster operator: The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer: The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin: The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole. We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all the above roles replicates the self-service model.","title":"Rolespersonas"},{"location":"concepts/rolespersonas/#roles-and-personas","text":"In the original design of Kubernetes, Ingress and Service resources were based on a self-service model of usage; developers who create Services and Ingresses control all aspects of defining and exposing their applications to their users. We have found that the self-service model does not fully capture some of the more complex deployment and team structures that our users are seeing. Gateway API is designed to target the following personas: Infrastructure provider: The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, ...) or the PaaS provider in a company. Cluster operator: The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions. Application developer: The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends). Although these roles can cover a wide variety of use cases, some organizations may be structured slightly differently. Many organizations may also have a fourth role that sits between \"cluster operator\" and \"application developer\": Application admin: The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole. We expect that each persona will map approximately to a Role in the Kubernetes Role-Based Authentication (RBAC) system and will define resource model responsibility and separation. Depending on the environment, multiple roles can map to the same user. For example, giving the user all the above roles replicates the self-service model.","title":"Roles and personas"},{"location":"deploy/","text":"Prepare a Kubernetes cluster \u00b6 You\u2019ll need a Kubernetes cluster to run the Controller. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: The Controller can run As a standalone program with local kubeconfig file(by default: ~/.kube/config), or In In-Cluster mode, then, specified ServiceAccount and ClusterRole/ClusterRoleBinding are required, see here Kubernetes CNI Setup \u00b6 To make BIG-IP as the Gateway for the business traffic, we need to setup both K8S and BIG-IP\u2019s networks for different CNI types. The relavent network setup of BIG-IP side is handled by Controller automatically when the controller is started. Here, we only focus on configuring networks of Kubernetes side manually. For different CNIs, we have different configuration steps as following. Flannel \u00b6 In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node as a virtual node of the Kubernetes cluster. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node. In Calico mode \u00b6 In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"Prepare a Kubernetes cluster"},{"location":"deploy/#prepare-a-kubernetes-cluster","text":"You\u2019ll need a Kubernetes cluster to run the Controller. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: The Controller can run As a standalone program with local kubeconfig file(by default: ~/.kube/config), or In In-Cluster mode, then, specified ServiceAccount and ClusterRole/ClusterRoleBinding are required, see here","title":"Prepare a Kubernetes cluster"},{"location":"deploy/#kubernetes-cni-setup","text":"To make BIG-IP as the Gateway for the business traffic, we need to setup both K8S and BIG-IP\u2019s networks for different CNI types. The relavent network setup of BIG-IP side is handled by Controller automatically when the controller is started. Here, we only focus on configuring networks of Kubernetes side manually. For different CNIs, we have different configuration steps as following.","title":"Kubernetes CNI Setup"},{"location":"deploy/#flannel","text":"In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node as a virtual node of the Kubernetes cluster. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node.","title":"Flannel"},{"location":"deploy/#in-calico-mode","text":"In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"In Calico mode"},{"location":"deploy/installation/","text":"Installation \u00b6 Please prepare your K8S and BIG-IP in advance. In the code repository , we provide the Gateway API deployment YAML files for installation. The files are numbered and can complete the deployment process in order, where: file name functionality notes 0.prepare-certificates.yaml Use cert-manager.io to generate Secret for webhook CA/cert/key No further input is required 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs-v0.6.0.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy BIG-IP Kubernetes GatewayAPI Controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: , webhook certificates and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 0 .prepare-certificates.yaml # Optional $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster. View deployment pod via $ kubectl get deployment -n kube-system . View the run log via $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters . For uninstallation, see Uninstallation .","title":"Installation"},{"location":"deploy/installation/#installation","text":"Please prepare your K8S and BIG-IP in advance. In the code repository , we provide the Gateway API deployment YAML files for installation. The files are numbered and can complete the deployment process in order, where: file name functionality notes 0.prepare-certificates.yaml Use cert-manager.io to generate Secret for webhook CA/cert/key No further input is required 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs-v0.6.0.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy BIG-IP Kubernetes GatewayAPI Controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: , webhook certificates and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 0 .prepare-certificates.yaml # Optional $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster. View deployment pod via $ kubectl get deployment -n kube-system . View the run log via $ kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters . For uninstallation, see Uninstallation .","title":"Installation"},{"location":"deploy/parameters/","text":"Parameters \u00b6 By running the following command, we can get the full list of startup parameters: Note: Update the release version v0.2.1-20230411 to your own case. $ docker run f5devcentral/bigip-kubernetes-gateway:v0.2.1-20230411 /bigip-kubernetes-gateway-controller-linux --help Usage of /bigip-kubernetes-gateway-controller-linux: -bigip-config-directory string Directory of bigip-k8s-gw-conf.yaml file. ( default \"/bigip-config\" ) -bigip-credential-directory string Directory that contains the BIG-IP password file. To be used instead of bigip-password arguments. ( default \"/bigip-credential\" ) -certificate-directory string Directory that contains tls.crt and tls.key for webook https server. ( default \"/certificate-directory\" ) -controller-name string This controller name. ( default \"f5.io/gateway-controller-name\" ) -health-probe-bind-address string The address the probe endpoint binds to. ( default \":8081\" ) -kubeconfig string Paths to a kubeconfig. Only required if out-of-cluster. -leader-elect Enable leader election for controller manager. Enabling this will ensure there is only one active controller manager. -log-level string The log level, valid values: trace, debug, info, warn, error ( default \"info\" ) -metrics-bind-address string The address the metric endpoint binds to. ( default \":8080\" ) -validates string The items to validate synchronizingly, on operations concating multiple values with ',' , valid values: gateway.listeners.tls.certificateRefs,httproute.parentRefs,httproute.rules.backendRefs,gateway.gatewayClassName Some of those parameters require our attentions: --bigip-config-directory Additional BIG-IP configuration is passed in via a separate Kubernetes ConfigMap. In the installation YAML, the ConfigMap is mounted as Controller deployment's volumeMounts . See BIG-IP Configuration for explaination of the ConfigMap content. --bigip-credential-directory The password of BIG-IP is passed in via a Kubernetes Secret. In the installation YAML, the Secret is mounted as Controller deployment's volumeMounts . --certificate-directory When started, the Controller also works as a webhook server, we need to configure the certificates(CA/cert/key stored as a Secret) since K8S interacts with the webhook server through HTTPS. In the installation YAML, the Secret is mounted as Controller deployment's volumeMounts . --validates (>=v0.2.1) In some cases, users may want to perform checks on their defined YAML files before making actual changes to Kubernetes. If the YAML content does not meet the relevant conditions, the controller can provide feedback so that the YAML content can be adjusted accordingly. In controller, we use Webhook mechanism to achieve this. When '--validates' is used at controller starts, the controller will check the referred resources' situation. More details about its usage, see example . In the installation YAML file deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml , there is a sample of startup parameters: \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , \"--certificate-directory=/tmp/k8s-webhook-server/serving-certs\" BIG-IP Configuration \u00b6 The mentioned ConfigMap above contains BIG-IP connection information and configuration items for network setup. The Controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are commented: # BIG-IP management information - management : # username, must be admin username : admin # management IP address for iControl Rest ipAddress : 10.250.2.219 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode # if it is commented (# flannel level), # there will be no flannel configuration to k8s or bigip flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) # this will be referred in nodeConfigs part. localAddress : 10.250.17.219 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # vlan or tunnel name, should match one of the tunnels vlanOrTunnelName : fl-tunnel - name : self-17 ipMask : 10.250.17.219/24 vlanOrTunnelName : vlan-17 # configuration for bigip virtual node on k8s side nodeConfigs : # the public ip for vxlan tunnel connection # it will report error if it is not found in tunnels array - publicIP : 10.250.17.219 # the pod CIDR, should match that in selfIPs' 'ipMask' # note that, the mask is different podCIDR : 10.42.20.0/24 # optional, underlay network configuration for calico CNI mode # if it is commented, 'calico' should also be commented: # calico # there will be no calico configuration to k8s or bigip calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as # self ips for bgp endpoint selfIPs : # it is as same as that in flannel port. - name : self-17 ipMask : 10.250.17.220/24 vlanOrTunnelName : vlan-17 # the self ip used as the peer to interconnect with k8s. peerIPs : - 10.250.17.220 Note: If we don't want to configure BIG-IP in flannel or calico mode, just remove/comment the flannel and calico parts(The keyword flannel and calico should be commented as well). Thus the Controller will keep the CNI configurations on BIG-IP as user configured them manually in advance.","title":"Parameters"},{"location":"deploy/parameters/#parameters","text":"By running the following command, we can get the full list of startup parameters: Note: Update the release version v0.2.1-20230411 to your own case. $ docker run f5devcentral/bigip-kubernetes-gateway:v0.2.1-20230411 /bigip-kubernetes-gateway-controller-linux --help Usage of /bigip-kubernetes-gateway-controller-linux: -bigip-config-directory string Directory of bigip-k8s-gw-conf.yaml file. ( default \"/bigip-config\" ) -bigip-credential-directory string Directory that contains the BIG-IP password file. To be used instead of bigip-password arguments. ( default \"/bigip-credential\" ) -certificate-directory string Directory that contains tls.crt and tls.key for webook https server. ( default \"/certificate-directory\" ) -controller-name string This controller name. ( default \"f5.io/gateway-controller-name\" ) -health-probe-bind-address string The address the probe endpoint binds to. ( default \":8081\" ) -kubeconfig string Paths to a kubeconfig. Only required if out-of-cluster. -leader-elect Enable leader election for controller manager. Enabling this will ensure there is only one active controller manager. -log-level string The log level, valid values: trace, debug, info, warn, error ( default \"info\" ) -metrics-bind-address string The address the metric endpoint binds to. ( default \":8080\" ) -validates string The items to validate synchronizingly, on operations concating multiple values with ',' , valid values: gateway.listeners.tls.certificateRefs,httproute.parentRefs,httproute.rules.backendRefs,gateway.gatewayClassName Some of those parameters require our attentions: --bigip-config-directory Additional BIG-IP configuration is passed in via a separate Kubernetes ConfigMap. In the installation YAML, the ConfigMap is mounted as Controller deployment's volumeMounts . See BIG-IP Configuration for explaination of the ConfigMap content. --bigip-credential-directory The password of BIG-IP is passed in via a Kubernetes Secret. In the installation YAML, the Secret is mounted as Controller deployment's volumeMounts . --certificate-directory When started, the Controller also works as a webhook server, we need to configure the certificates(CA/cert/key stored as a Secret) since K8S interacts with the webhook server through HTTPS. In the installation YAML, the Secret is mounted as Controller deployment's volumeMounts . --validates (>=v0.2.1) In some cases, users may want to perform checks on their defined YAML files before making actual changes to Kubernetes. If the YAML content does not meet the relevant conditions, the controller can provide feedback so that the YAML content can be adjusted accordingly. In controller, we use Webhook mechanism to achieve this. When '--validates' is used at controller starts, the controller will check the referred resources' situation. More details about its usage, see example . In the installation YAML file deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml , there is a sample of startup parameters: \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , \"--certificate-directory=/tmp/k8s-webhook-server/serving-certs\"","title":"Parameters"},{"location":"deploy/parameters/#big-ip-configuration","text":"The mentioned ConfigMap above contains BIG-IP connection information and configuration items for network setup. The Controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are commented: # BIG-IP management information - management : # username, must be admin username : admin # management IP address for iControl Rest ipAddress : 10.250.2.219 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode # if it is commented (# flannel level), # there will be no flannel configuration to k8s or bigip flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) # this will be referred in nodeConfigs part. localAddress : 10.250.17.219 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # vlan or tunnel name, should match one of the tunnels vlanOrTunnelName : fl-tunnel - name : self-17 ipMask : 10.250.17.219/24 vlanOrTunnelName : vlan-17 # configuration for bigip virtual node on k8s side nodeConfigs : # the public ip for vxlan tunnel connection # it will report error if it is not found in tunnels array - publicIP : 10.250.17.219 # the pod CIDR, should match that in selfIPs' 'ipMask' # note that, the mask is different podCIDR : 10.42.20.0/24 # optional, underlay network configuration for calico CNI mode # if it is commented, 'calico' should also be commented: # calico # there will be no calico configuration to k8s or bigip calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as # self ips for bgp endpoint selfIPs : # it is as same as that in flannel port. - name : self-17 ipMask : 10.250.17.220/24 vlanOrTunnelName : vlan-17 # the self ip used as the peer to interconnect with k8s. peerIPs : - 10.250.17.220 Note: If we don't want to configure BIG-IP in flannel or calico mode, just remove/comment the flannel and calico parts(The keyword flannel and calico should be commented as well). Thus the Controller will keep the CNI configurations on BIG-IP as user configured them manually in advance.","title":"BIG-IP Configuration"},{"location":"deploy/uninstall/","text":"Uninstallation \u00b6 The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Uninstallation"},{"location":"deploy/uninstall/#uninstallation","text":"The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Uninstallation"},{"location":"guides/allowedroutes/","text":"Gateway and Route Attachment Spec: AllowedRoutes \u00b6 Supported from v0.1.1 Note: The full deployment yaml files can be found: pre.yaml : the GatewayClass \"bigip\" and the Namespace \"abcd\" api.yaml : the Gateway \"mygateway\" and HTTPRoute s \"route1\" and \"route2\" svc.yaml : the Service s \"test-service\" and \"dev-service\" As the SIG GatewayAPI mentioned at the beginning of the page : \" The Gateway API has core support for cross Namespace routing. This is useful when more than one user or team is sharing the underlying networking infrastructure, yet control and configuration must be segmented to minimize access and fault domains. Gateways and Routes can be deployed into different Namespaces and Routes can attach to Gateways across Namespace boundaries. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration. The ability for Routes to attach to Gateways across Namespace boundaries are governed by Route Attachment. Route attachment is explored in this guide and demonstrates how independent teams can safely share the same Gateway. \". In summary, a route can be attached to a gateway under another namespace. This attachment is restricted by the \"AllowedRoutes\" field in the listener definition of the gateway. It is highly recommended that you read the official website's interpretation of Cross-Namespace Routing Usecase . In this page, we focus on 9 cases of configuration practices of AllowedRoutes . To demonstrate the configurations, we have a Gateway named \"mygateway\", 2 HTTPRoute s named \"route1\" and \"route2\" and 2 Service s named \"test-service\" and \"dev-service\". \"route2\" is in a different namespace as shown in the above figure. It can be attached to \"mygateway\" only when the AllowedRoutes in \"mygateway\" is configured right . In the 2 HTTPRoute s, the parentRefs defines the attaching Gateway 's listener: spec : parentRefs : - namespace : default name : mygateway sectionName : listenerx Refer here for the full definition of \"route1\" and \"route2\", and here for Service 's definitions. The Gateway : \"mygateway\" definition is: --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : listenerx port : 80 protocol : HTTP # 1. no \"allowedRoutes\" definition # # 2. from all namespaces # allowedRoutes: # namespaces: # from: All # 3. from same namespace # allowedRoutes: # namespaces: # from: Same # 4. use selector's matchLabels # allowedRoutes: # namespaces: # from: Selector # selector: # matchLabels: # resource.zone: allowed-namespaces # 5. use selector's matchExpressions # allowedRoutes: # namespaces: # from: Selector # selector: # matchExpressions: # - key: resource.zone # operator: In # values: # - allowed-namespaces # 6. use kinds = [] # allowedRoutes: # kinds: [] # 7. use kinds with items specified -- no HTTPRoute # allowedRoutes: # kinds: # - kind: TLSRoute # - kind: TCPRoute # 8. use kinds with items specified -- has HTTPRoute # allowedRoutes: # kinds: # - group: gateway.networking.k8s.io # kind: HTTPRoute # - kind: TCPRoute # # group defaults to \"gateway.networking.k8s.io\" # 9. use kinds with items specified -- group is ingress # allowedRoutes: # kinds: # - group: ingress.networking.k8s.io # kind: HTTPRoute addresses : - value : 10.250.18.119 Refer here for GatewayClass and namespace abcd definition. We have 9 cases of configurations above: # 1. no \"allowedRoutes\" definition # When there is no allowedRoutes defined in the Listener of Gateway , the AllowedRoutes defaults to from: Same and kinds: HTTP , that means only \"route1\" from \"default\" namespace can be mounted to \"mygateway\". Refer to AllowedRoutes Spec for more \"default\" details: * namespaces: \"This is restricted to the namespace of this Gateway by default.\" * kinds: \"When unspecified or empty, the kinds of Routes selected are determined using the Listener protocol.\" # 2. from all namespaces # allowedRoutes: # namespaces: # from: All When namespaces is set \"All\", both \"route1\" and \"route2\" can be attached. That means HTTPRoute from any namespaces can be attached to \"mygateway\". # 3. from same namespace # allowedRoutes: # namespaces: # from: Same This case is as same as case 1, only HTTPRoute \"route1\" from \"default\" namespace can be attached. # 4. use selector's matchLabels # allowedRoutes: # namespaces: # from: Selector # selector: # matchLabels: # resource.zone: allowed-namespaces The label \"resource.zone: allowed-namespaces\" matches Namespace \"abcd\", so only \"route2\" from \"abcd\" namespace can be attached. # 5. use selector's matchExpressions # allowedRoutes: # namespaces: # from: Selector # selector: # matchExpressions: # - key: resource.zone # operator: In # values: # - allowed-namespaces It have the same effect with case 4, however, it have more filtering options than matchLabels . See here for more details about LabelSelector . # 6. use kinds = [] # allowedRoutes: # kinds: [] When kinds is an empty list, the namespaces will default to Same , and the kind match default to same protocol, that means \"mygateway\" Listener \"listenerx\"'s HTTP protocol must match route's type HTTPRoute . # 7. use kinds with items specified -- no HTTPRoute # allowedRoutes: # kinds: # - kind: TLSRoute # - kind: TCPRoute There's no match for HTTPRoute , so no route will be attached to \"mygateway\". # 8. use kinds with items specified -- has HTTPRoute # allowedRoutes: # kinds: # - group: gateway.networking.k8s.io # kind: HTTPRoute # - kind: TCPRoute # # group defaults to \"gateway.networking.k8s.io\" HTTPRoute matches \"route1\" and \"route2\", but only \"route1\" from the same namespace can be attached to \"mygateway\". # 9. use kinds with items specified -- group is ingress # allowedRoutes: # kinds: # - group: ingress.networking.k8s.io # kind: HTTPRoute group name is not matched. Only gateway.network.k8s.io is supported. You may also get the video demonstration: video .","title":"Allowedroutes"},{"location":"guides/allowedroutes/#gateway-and-route-attachment-spec-allowedroutes","text":"Supported from v0.1.1 Note: The full deployment yaml files can be found: pre.yaml : the GatewayClass \"bigip\" and the Namespace \"abcd\" api.yaml : the Gateway \"mygateway\" and HTTPRoute s \"route1\" and \"route2\" svc.yaml : the Service s \"test-service\" and \"dev-service\" As the SIG GatewayAPI mentioned at the beginning of the page : \" The Gateway API has core support for cross Namespace routing. This is useful when more than one user or team is sharing the underlying networking infrastructure, yet control and configuration must be segmented to minimize access and fault domains. Gateways and Routes can be deployed into different Namespaces and Routes can attach to Gateways across Namespace boundaries. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration. The ability for Routes to attach to Gateways across Namespace boundaries are governed by Route Attachment. Route attachment is explored in this guide and demonstrates how independent teams can safely share the same Gateway. \". In summary, a route can be attached to a gateway under another namespace. This attachment is restricted by the \"AllowedRoutes\" field in the listener definition of the gateway. It is highly recommended that you read the official website's interpretation of Cross-Namespace Routing Usecase . In this page, we focus on 9 cases of configuration practices of AllowedRoutes . To demonstrate the configurations, we have a Gateway named \"mygateway\", 2 HTTPRoute s named \"route1\" and \"route2\" and 2 Service s named \"test-service\" and \"dev-service\". \"route2\" is in a different namespace as shown in the above figure. It can be attached to \"mygateway\" only when the AllowedRoutes in \"mygateway\" is configured right . In the 2 HTTPRoute s, the parentRefs defines the attaching Gateway 's listener: spec : parentRefs : - namespace : default name : mygateway sectionName : listenerx Refer here for the full definition of \"route1\" and \"route2\", and here for Service 's definitions. The Gateway : \"mygateway\" definition is: --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : listenerx port : 80 protocol : HTTP # 1. no \"allowedRoutes\" definition # # 2. from all namespaces # allowedRoutes: # namespaces: # from: All # 3. from same namespace # allowedRoutes: # namespaces: # from: Same # 4. use selector's matchLabels # allowedRoutes: # namespaces: # from: Selector # selector: # matchLabels: # resource.zone: allowed-namespaces # 5. use selector's matchExpressions # allowedRoutes: # namespaces: # from: Selector # selector: # matchExpressions: # - key: resource.zone # operator: In # values: # - allowed-namespaces # 6. use kinds = [] # allowedRoutes: # kinds: [] # 7. use kinds with items specified -- no HTTPRoute # allowedRoutes: # kinds: # - kind: TLSRoute # - kind: TCPRoute # 8. use kinds with items specified -- has HTTPRoute # allowedRoutes: # kinds: # - group: gateway.networking.k8s.io # kind: HTTPRoute # - kind: TCPRoute # # group defaults to \"gateway.networking.k8s.io\" # 9. use kinds with items specified -- group is ingress # allowedRoutes: # kinds: # - group: ingress.networking.k8s.io # kind: HTTPRoute addresses : - value : 10.250.18.119 Refer here for GatewayClass and namespace abcd definition. We have 9 cases of configurations above: # 1. no \"allowedRoutes\" definition # When there is no allowedRoutes defined in the Listener of Gateway , the AllowedRoutes defaults to from: Same and kinds: HTTP , that means only \"route1\" from \"default\" namespace can be mounted to \"mygateway\". Refer to AllowedRoutes Spec for more \"default\" details: * namespaces: \"This is restricted to the namespace of this Gateway by default.\" * kinds: \"When unspecified or empty, the kinds of Routes selected are determined using the Listener protocol.\" # 2. from all namespaces # allowedRoutes: # namespaces: # from: All When namespaces is set \"All\", both \"route1\" and \"route2\" can be attached. That means HTTPRoute from any namespaces can be attached to \"mygateway\". # 3. from same namespace # allowedRoutes: # namespaces: # from: Same This case is as same as case 1, only HTTPRoute \"route1\" from \"default\" namespace can be attached. # 4. use selector's matchLabels # allowedRoutes: # namespaces: # from: Selector # selector: # matchLabels: # resource.zone: allowed-namespaces The label \"resource.zone: allowed-namespaces\" matches Namespace \"abcd\", so only \"route2\" from \"abcd\" namespace can be attached. # 5. use selector's matchExpressions # allowedRoutes: # namespaces: # from: Selector # selector: # matchExpressions: # - key: resource.zone # operator: In # values: # - allowed-namespaces It have the same effect with case 4, however, it have more filtering options than matchLabels . See here for more details about LabelSelector . # 6. use kinds = [] # allowedRoutes: # kinds: [] When kinds is an empty list, the namespaces will default to Same , and the kind match default to same protocol, that means \"mygateway\" Listener \"listenerx\"'s HTTP protocol must match route's type HTTPRoute . # 7. use kinds with items specified -- no HTTPRoute # allowedRoutes: # kinds: # - kind: TLSRoute # - kind: TCPRoute There's no match for HTTPRoute , so no route will be attached to \"mygateway\". # 8. use kinds with items specified -- has HTTPRoute # allowedRoutes: # kinds: # - group: gateway.networking.k8s.io # kind: HTTPRoute # - kind: TCPRoute # # group defaults to \"gateway.networking.k8s.io\" HTTPRoute matches \"route1\" and \"route2\", but only \"route1\" from the same namespace can be attached to \"mygateway\". # 9. use kinds with items specified -- group is ingress # allowedRoutes: # kinds: # - group: ingress.networking.k8s.io # kind: HTTPRoute group name is not matched. Only gateway.network.k8s.io is supported. You may also get the video demonstration: video .","title":"Gateway and Route Attachment Spec: AllowedRoutes"},{"location":"guides/getstarted/","text":"Getting started with BIG-IP Kubernetes Gateway Controller \u00b6 First : Install BIG-IP Kubernetes Gateway Controller Please refer to the installation and parameter for the installation and startup. The references for deployment: prerequirement installation uninstallation controller parameters Then : Try out one of the available usecases: Simple Gateway HTTP routing HTTP redirects and rewrites HTTP traffic splitting Cross-Namespace routing HTTPS Gateway TCP routing gRPC routing","title":"Getting started"},{"location":"guides/getstarted/#getting-started-with-big-ip-kubernetes-gateway-controller","text":"First : Install BIG-IP Kubernetes Gateway Controller Please refer to the installation and parameter for the installation and startup. The references for deployment: prerequirement installation uninstallation controller parameters Then : Try out one of the available usecases: Simple Gateway HTTP routing HTTP redirects and rewrites HTTP traffic splitting Cross-Namespace routing HTTPS Gateway TCP routing gRPC routing","title":"Getting started with BIG-IP Kubernetes Gateway Controller"},{"location":"guides/grpc-routing/","text":"gRPC routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"gRPC Routing"},{"location":"guides/grpc-routing/#grpc-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"gRPC routing"},{"location":"guides/http-redirect-rewrite/","text":"HTTP path redirects and rewrites \u00b6 HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Redirects \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently . Rewrites \u00b6 Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"HTTP Redirects and Rewrites"},{"location":"guides/http-redirect-rewrite/#http-path-redirects-and-rewrites","text":"HTTPRoute can be used to redirect clients' request or rewrite the paths sent to the backends using filters . In this page, we will show how to use the filters to do the redirect or rewrite. We ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP path redirects and rewrites"},{"location":"guides/http-redirect-rewrite/#redirects","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-filter-requestredirect spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - filters : - type : RequestRedirect requestRedirect : scheme : https hostname : www.example.com # path: -> experimental in v0.5.1 # type: ReplaceFullPath # replaceFullPath: /fake port : 443 statusCode : 301 backendRefs : - name : tea port : 80 In this HTTPRoute configuration, when we access http://gateway.test.automation , the traffic will be redirect to https://www.example.com/ : $ curl 10 .250.18.119 -H \"Host: gateway.test.automation\" -v * Trying 10 .250.18.119:80... * Connected to 10 .250.18.119 ( 10 .250.18.119 ) port 80 ( #0) > GET / HTTP/1.1 > Host: gateway.test.automation > User-Agent: curl/7.79.1 > Accept: */* > * Mark bundle as not supporting multiuse * HTTP 1 .0, assume close after body < HTTP/1.0 301 Moved Permanently < Location: https://www.example.com:443/ < Server: BigIP * HTTP/1.0 connection set to keep alive! < Connection: Keep-Alive < Content-Length: 0 < * Connection #0 to host 10.250.18.119 left intact As shown here, the virtual responses < HTTP/1.0 301 Moved Permanently .","title":"Redirects"},{"location":"guides/http-redirect-rewrite/#rewrites","text":"Experimental in gateway api v0.5.1, will be supported in future. # --- # apiVersion: gateway.networking.k8s.io/v1beta1 # kind: HTTPRoute # metadata: # name: test-filter-urlrewrite # spec: # parentRefs: # - name: gateway # sectionName: http # hostnames: # - \"cafe.example.com\" # rules: # - filters: # - type: URLRewrite # urlRewrite: # hostname: www.example.com # path: # type: ReplaceFullPath # replaceFullPath: /fake # backendRefs: # - name: tea # port: 80","title":"Rewrites"},{"location":"guides/http-routing/","text":"HTTP Routing \u00b6 In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources. Request header based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80. Request method based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80. Request path based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80. Request parameter based matching \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80. Multiple matches in a HTTPRoute \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"HTTP Routing"},{"location":"guides/http-routing/#http-routing","text":"In this scenario, based on Simple Gateway , we demonstrate the process of binding multiple httproutes in one gateway to forward traffic with different characteristics, to different backend servers. In this page, we ignore the configuration of GatewayClass and Gateway , and directly show the configurations of different HTTPRoute resources.","title":"HTTP Routing"},{"location":"guides/http-routing/#request-header-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-header spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the domain name of the request is gateway.test.automation and the request header contains test == automation , the traffic is forwarded to the test-service service with port 80.","title":"Request header based matching"},{"location":"guides/http-routing/#request-method-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-method spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - method : GET - method : OPTIONS backendRefs : - name : test-service port : 80 When the domain name is gateway.test.automation and the request method is GET or OPTIONS , the request is forwarded to the test-service service with port 80.","title":"Request method based matching"},{"location":"guides/http-routing/#request-path-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-match-path spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /path-test backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation and the request path is /path-test , the request is forwarded to the test-service service with port 80.","title":"Request path based matching"},{"location":"guides/http-routing/#request-parameter-based-matching","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-query-params spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation backendRefs : - name : test-service port : 80 When the request domain name is gateway.test.automation , and the request parameters contain ?test=automation , the request is forwarded to the test-service service with port 80.","title":"Request parameter based matching"},{"location":"guides/http-routing/#multiple-matches-in-a-httproute","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-multiple-rules spec : parentRefs : - name : gateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - queryParams : - name : test value : automation path : type : PathPrefix value : /path-test backendRefs : - name : test-service1 port : 80 - matches : - queryParams : - name : test value : automation - path : type : PathPrefix value : /path-test backendRefs : - name : test-service2 port : 80 - backendRefs : - name : test-service3 port : 80 When the request domain name is gateway.test.automation , and If the path of the request is /path-test , AND the request parameters contain ?test=automation , the request will be forwarded to the test-service1 service, port 80. If the path of the request is /path-test , OR the request parameters contain ?test=automation , (only one of the 2 conditions) , the request will be forwarded to the test-service2 service, port 80. In other cases, it is forwarded to the test-service3 service, port 80.","title":"Multiple matches in a HTTPRoute"},{"location":"guides/multiple-ns/","text":"Cross-Namespace routing \u00b6 In this scenario, we demonstrate the process of attaching httproute to gateway which might be in a different namespace. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration. Gateway allows Routes from all namespaces \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : All addresses : - value : 10.250.15.2 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-all namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is All , it means this gateway does not care what namespace the routes are from. So although the Gateway and HTTPRoute are from different namespaces above, it does not matter. Gateway allows Routes from the same namespace \u00b6 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : default labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Same addresses : - value : 10.25.15.3 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-same namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : default hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Same , it means this gateway only allowes routes from the same namespace to attach to it. In the example above, both the gateway and HTTPRoute are from default namespace. Gateway allows Routes from namespaces filtered by namespace selector \u00b6 --- apiVersion : v1 kind : Namespace metadata : name : newlable-ns labels : newlable : \"newlable\" --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Selector selector : matchLabels : newlable : \"newlable\" addresses : - value : 10.25.15.4 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-selector namespace : newlable-ns spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Selector , it means this gateway allows routes from those namespaces that satisfy the namespace selector. In this example, routes whose namespace has label newlable=newlable are allowed to attach to the gateway. Besides AllowedRoutes.namespaces.From , AllowedRoutes.namespaces.Kinds determines which kinds of routes can be attached to Gateway . For some advanced configuration of AllowedRoutes , refer to here for more details.","title":"Cross-Namespace Routing"},{"location":"guides/multiple-ns/#cross-namespace-routing","text":"In this scenario, we demonstrate the process of attaching httproute to gateway which might be in a different namespace. This allows user access control to be applied differently across Namespaces for Routes and Gateways, effectively segmenting access and control to different parts of the cluster-wide routing configuration.","title":"Cross-Namespace routing"},{"location":"guides/multiple-ns/#gateway-allows-routes-from-all-namespaces","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : All addresses : - value : 10.250.15.2 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-all namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is All , it means this gateway does not care what namespace the routes are from. So although the Gateway and HTTPRoute are from different namespaces above, it does not matter.","title":"Gateway allows Routes from all namespaces"},{"location":"guides/multiple-ns/#gateway-allows-routes-from-the-same-namespace","text":"--- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : default labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Same addresses : - value : 10.25.15.3 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-same namespace : default spec : parentRefs : - name : gateway201 sectionName : http namespace : default hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Same , it means this gateway only allowes routes from the same namespace to attach to it. In the example above, both the gateway and HTTPRoute are from default namespace.","title":"Gateway allows Routes from the same namespace"},{"location":"guides/multiple-ns/#gateway-allows-routes-from-namespaces-filtered-by-namespace-selector","text":"--- apiVersion : v1 kind : Namespace metadata : name : newlable-ns labels : newlable : \"newlable\" --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : gateway201 namespace : namespace1 labels : domain : k8s-gateway spec : gatewayClassName : bigip36 listeners : - name : http port : 80 protocol : HTTP allowedRoutes : namespaces : from : Selector selector : matchLabels : newlable : \"newlable\" addresses : - value : 10.25.15.4 --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : test-ns-selector namespace : newlable-ns spec : parentRefs : - name : gateway201 sectionName : http namespace : namespace1 hostnames : - gateway.test.automation rules : - matches : - headers : - name : test value : automation backendRefs : - name : test-service port : 80 When the value of allowedRoutes.namespaces.from is Selector , it means this gateway allows routes from those namespaces that satisfy the namespace selector. In this example, routes whose namespace has label newlable=newlable are allowed to attach to the gateway. Besides AllowedRoutes.namespaces.From , AllowedRoutes.namespaces.Kinds determines which kinds of routes can be attached to Gateway . For some advanced configuration of AllowedRoutes , refer to here for more details.","title":"Gateway allows Routes from namespaces filtered by namespace selector"},{"location":"guides/service-definition/","text":"The servcie definitions for references only Note that: tea servcie is defined as NodePort and coffee service is ClusterIP . Change it as necessary. tea.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello}; coffee.yaml \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"Service definition"},{"location":"guides/service-definition/#teayaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : tea spec : replicas : 1 selector : matchLabels : app : tea template : metadata : labels : app : tea spec : containers : - name : tea image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-tea --- apiVersion : v1 kind : Service metadata : name : tea spec : type : NodePort ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : tea --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-tea data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"TEA\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"tea.yaml"},{"location":"guides/service-definition/#coffeeyaml","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : coffee spec : replicas : 1 selector : matchLabels : app : coffee template : metadata : labels : app : coffee spec : containers : - name : coffee image : nginx:latest ports : - containerPort : 80 volumeMounts : - name : config-volume mountPath : /etc/nginx/nginx.conf subPath : nginx.conf - name : config-volume mountPath : /etc/nginx/njs/dumps.js subPath : dumps.js volumes : - name : config-volume configMap : name : nginx-config-coffee --- apiVersion : v1 kind : Service metadata : name : coffee spec : type : ClusterIP ports : - port : 80 targetPort : 80 protocol : TCP name : http selector : app : coffee --- apiVersion : v1 kind : ConfigMap metadata : name : nginx-config-coffee data : nginx.conf : | user nginx; worker_processes 1; load_module modules/ngx_http_js_module.so; events { worker_connections 1024; } http { js_import njs/dumps.js; server { listen 80; server_name localhost; location / { js_content dumps.hello; } } } dumps.js : | function hello(r) { let d = { 'queries': r.args, 'headers': r.headersIn, 'version': r.httpVersion, 'method': r.method, 'remote-address': r.remoteAddress, 'body': r.requestText, 'uri': r.uri, 'server_name': \"COFFEE\" } r.return(200, JSON.stringify(d)+\"\\n\"); } export default {hello};","title":"coffee.yaml"},{"location":"guides/simple-gateway/","text":"Deploying a simple Gateway \u00b6 Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Simple Gateway"},{"location":"guides/simple-gateway/#deploying-a-simple-gateway","text":"Just like the official website describes here , a Gateway can be deployed as an ingress. In this page, we provide another version of a simple gateway deployment. In this usecase, we will have a preliminary understanding of the definition methods of HTTPRoute and related resources, and understand how HTTPRoute achieves the routing and forwarding capability of requests. To demo this simple HTTPRoute usecase, we will create an HTTPRoute resource that defines traffic forwarding rules, and we need to create the GatewayClass and Gateway resource on which it depends. To demonstrate the effect, we also need to create a Service resource. When we access the ingress IP defined in the Gateway , the traffic is forwarded to the backend service by the rule defined in HTTPRoute . gatewayclass.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : GatewayClass metadata : name : bigip spec : controllerName : f5.io/gateway-controller-name gateway.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : Gateway metadata : name : mygateway labels : domain : k8s-gateway spec : gatewayClassName : bigip listeners : - name : http port : 80 protocol : HTTP addresses : - value : 10.250.17.120 httproute.yaml --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test headers : - name : svc value : coffee filters : - type : RequestHeaderModifier requestHeaderModifier : add : - name : tester value : f5 backendRefs : - name : coffee port : 80 Refer here for coffee definition. In the above demo, the rules in httproute.yaml contains two parts: matches and filters , matches defines route matching rules, and filters defines the customization process for requests. matches: /test path also contains svc==coffee in the header filters: Add a new header tester = f5 therefore, $ curl 10 .250.17.120/test -H \"Host: gateway.test.automation\" -H \"svc: coffee\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.test.automation\" , \"User-Agent\" : \"curl/7.79.1\" , \"Accept\" : \"*/*\" , \"svc\" : \"coffee\" , \"tester\" : \"f5\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.7.0\" , \"uri\" : \"/test\" , \"server_name\" : \"COFFEE\" }","title":"Deploying a simple Gateway"},{"location":"guides/tcp/","text":"TCP routing \u00b6 Experimental in gateway api v0.5.1, will be supported in future.","title":"TCP Routing"},{"location":"guides/tcp/#tcp-routing","text":"Experimental in gateway api v0.5.1, will be supported in future.","title":"TCP routing"},{"location":"guides/tls/","text":"TLS Configuration \u00b6 In this page, we focus on Terminated HTTPS usecase. We will add other TLS usecases soon. We can't talk about Gateway without talking about Terminated HTTPS. With Terminated HTTPS, we can make the gateway(BIG-IP in this implementation) to do the TLS offload, letting the backend services focus on business processing. Please find the resource yaml yamls from the example of code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/examples/https-gateway To setup a HTTPS gateway, the server certificate and private key are needed for setting up TLS handshake. In GatewayAPI, Secret type is used to provide the cert/key pair. In secret.yaml file, we provide a Secret with the tls cert and key. You may need to replace them with your owns. A recommended way to generate the Secret is cert-manager.io . ### 1. Create the Secret $ kubectl apply -f sercret.yaml In secret.yaml , we also define Namespace ReferenceGrant to demonstrate a cross namespace reference. This is closer to user scenarios that Secret s are usually be stored in a protected namespace. ### 2. Create the Service $ kubectl apply -f service.yaml The Service is as usual as that in Simple Gateway case. ### 3. Create other Gateway API Resources $ kubectl apply -f gatewayapis.yaml With gatewayapis.yaml , we create GatewayClass , Gateway and HTTPRoute in order. Verify the Deployed Gateway \u00b6 Access the https gateway: $ curl -k https://10.250.17.143/path-test -H \"Host: gateway.api\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.api\" , \"User-Agent\" : \"curl/7.86.0\" , \"Accept\" : \"*/*\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.20.1\" , \"uri\" : \"/path-test\" , \"server_name\" : \"bigip.test.service\" } You may also use --cacert ca.crt to appoint the CA certificate for verifying server certificate since the server certificate may be self-signed. Verify the Server Certificate Details \u00b6 $ openssl s_client -connect 10 .250.17.143:443 -showcerts CONNECTED ( 00000003 ) depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com verify error:num = 18 :self signed certificate verify return :1 depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com verify error:num = 10 :certificate has expired notAfter = Jan 6 03 :06:37 2022 GMT verify return :1 depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com notAfter = Jan 6 03 :06:37 2022 GMT verify return :1 write W BLOCK --- Certificate chain 0 s:/C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com i:/C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com -----BEGIN CERTIFICATE----- MIIDiDCCAnACCQCwsetXAEnCoDANBgkqhkiG9w0BAQUFADCBhTELMAkGA1UEBhMC Q04xCzAJBgNVBAgMAkJKMRAwDgYDVQQHDAdiZWlqaW5nMQswCQYDVQQKDAJmNTEU MBIGA1UECwwLem9uZy5mNS5jb20xFjAUBgNVBAMMDWEuem9uZy5mNS5jb20xHDAa BgkqhkiG9w0BCQEWDWEuem9uZ0BmNS5jb20wHhcNMjExMjA3MDMwNjM3WhcNMjIw MTA2MDMwNjM3WjCBhTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkJKMRAwDgYDVQQH DAdiZWlqaW5nMQswCQYDVQQKDAJmNTEUMBIGA1UECwwLem9uZy5mNS5jb20xFjAU BgNVBAMMDWEuem9uZy5mNS5jb20xHDAaBgkqhkiG9w0BCQEWDWEuem9uZ0BmNS5j b20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDgHLExdv8aok2MlQJn A7PI2+g/VUdAa2/cf7IkUtgv7XhDgk7OBcBw1ggNqAgLTqsY3o48aHUhAlQcLtSs h7XYxlbrdTLhiQc/DSqaf4yxlJ139RJ6qMlBBilkSCRtGBv7DUxGByxdweHr5Zwf qIGNw5f3lm5oF6htXL49sgYzUlljuiNhrq7eFZFBStUHNhobYUA8ZeOk/WyMDrup sb8VCLv/eAjxixNQeonlZC1DY/qpCATd/xYVOEyR6tDb41bXehmqbpFWnOumPEud zXI+O9q58tXfFTuUtGXP3xgaHaxSs9xk/Iqn5bpizlwIlLMSs/wVr/uCQbLMvAAL wvKbAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAMYEWzDtbjYlqOWtuaCUw2S3fJFB +IWwWVsu0LN6+a1OPIDpAb5/ueKGv4CNDi5bXLTSP2or4CsWpz4mzK0Zp3Gt12uG NeOI4IUOd+5c+X+eF8fuW42luXBXHsNZPT7HNFCVV2XmhtOE90TsR/qPVH4llDlJ K+aHk9dd/PCSgG6+S7wwQhUxLdM7prns6RmPbUT2Sr3r57jS3JJF56Ejk2/LLmNK XHPO+a5hOBuEcwpEtuBB64/uuY1z+5vLddFl/8snHbWAZEQdUD1k9Vo7XXmP/6ac fYc0k0zdhJcqg45ftWumTWuPBVxx78TdK6k5nN9+TDgB7gSnjCyu4JyAl0w = -----END CERTIFICATE----- --- Server certificate subject = /C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com issuer = /C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com --- No client certificate CA names sent Server Temp Key: ECDH, P-256, 256 bits --- SSL handshake has read 1413 bytes and written 413 bytes --- New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256 Server public key is 2048 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES128-GCM-SHA256 Session-ID: 80DFB369B58206AD28679B31DC8B6EF44E39B1569845E592F02644A52C9B3E85 Session-ID-ctx: Master-Key: 1076BE0419F11D713BE98913481C861EB2DB5012279DDA861095DE4460DF05633ED12A8CFEB6050E17937A938803617D Start Time: 1680753364 Timeout : 7200 ( sec ) Verify return code: 10 ( certificate has expired ) ---","title":"TLS"},{"location":"guides/tls/#tls-configuration","text":"In this page, we focus on Terminated HTTPS usecase. We will add other TLS usecases soon. We can't talk about Gateway without talking about Terminated HTTPS. With Terminated HTTPS, we can make the gateway(BIG-IP in this implementation) to do the TLS offload, letting the backend services focus on business processing. Please find the resource yaml yamls from the example of code repository: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/examples/https-gateway To setup a HTTPS gateway, the server certificate and private key are needed for setting up TLS handshake. In GatewayAPI, Secret type is used to provide the cert/key pair. In secret.yaml file, we provide a Secret with the tls cert and key. You may need to replace them with your owns. A recommended way to generate the Secret is cert-manager.io . ### 1. Create the Secret $ kubectl apply -f sercret.yaml In secret.yaml , we also define Namespace ReferenceGrant to demonstrate a cross namespace reference. This is closer to user scenarios that Secret s are usually be stored in a protected namespace. ### 2. Create the Service $ kubectl apply -f service.yaml The Service is as usual as that in Simple Gateway case. ### 3. Create other Gateway API Resources $ kubectl apply -f gatewayapis.yaml With gatewayapis.yaml , we create GatewayClass , Gateway and HTTPRoute in order.","title":"TLS Configuration"},{"location":"guides/tls/#verify-the-deployed-gateway","text":"Access the https gateway: $ curl -k https://10.250.17.143/path-test -H \"Host: gateway.api\" { \"queries\" : {} , \"headers\" : { \"Host\" : \"gateway.api\" , \"User-Agent\" : \"curl/7.86.0\" , \"Accept\" : \"*/*\" } , \"version\" : \"1.1\" , \"method\" : \"GET\" , \"remote-address\" : \"10.42.20.1\" , \"uri\" : \"/path-test\" , \"server_name\" : \"bigip.test.service\" } You may also use --cacert ca.crt to appoint the CA certificate for verifying server certificate since the server certificate may be self-signed.","title":"Verify the Deployed Gateway"},{"location":"guides/tls/#verify-the-server-certificate-details","text":"$ openssl s_client -connect 10 .250.17.143:443 -showcerts CONNECTED ( 00000003 ) depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com verify error:num = 18 :self signed certificate verify return :1 depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com verify error:num = 10 :certificate has expired notAfter = Jan 6 03 :06:37 2022 GMT verify return :1 depth = 0 C = CN, ST = BJ, L = beijing, O = f5, OU = zong.f5.com, CN = a.zong.f5.com, emailAddress = a.zong@f5.com notAfter = Jan 6 03 :06:37 2022 GMT verify return :1 write W BLOCK --- Certificate chain 0 s:/C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com i:/C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com -----BEGIN CERTIFICATE----- MIIDiDCCAnACCQCwsetXAEnCoDANBgkqhkiG9w0BAQUFADCBhTELMAkGA1UEBhMC Q04xCzAJBgNVBAgMAkJKMRAwDgYDVQQHDAdiZWlqaW5nMQswCQYDVQQKDAJmNTEU MBIGA1UECwwLem9uZy5mNS5jb20xFjAUBgNVBAMMDWEuem9uZy5mNS5jb20xHDAa BgkqhkiG9w0BCQEWDWEuem9uZ0BmNS5jb20wHhcNMjExMjA3MDMwNjM3WhcNMjIw MTA2MDMwNjM3WjCBhTELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkJKMRAwDgYDVQQH DAdiZWlqaW5nMQswCQYDVQQKDAJmNTEUMBIGA1UECwwLem9uZy5mNS5jb20xFjAU BgNVBAMMDWEuem9uZy5mNS5jb20xHDAaBgkqhkiG9w0BCQEWDWEuem9uZ0BmNS5j b20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDgHLExdv8aok2MlQJn A7PI2+g/VUdAa2/cf7IkUtgv7XhDgk7OBcBw1ggNqAgLTqsY3o48aHUhAlQcLtSs h7XYxlbrdTLhiQc/DSqaf4yxlJ139RJ6qMlBBilkSCRtGBv7DUxGByxdweHr5Zwf qIGNw5f3lm5oF6htXL49sgYzUlljuiNhrq7eFZFBStUHNhobYUA8ZeOk/WyMDrup sb8VCLv/eAjxixNQeonlZC1DY/qpCATd/xYVOEyR6tDb41bXehmqbpFWnOumPEud zXI+O9q58tXfFTuUtGXP3xgaHaxSs9xk/Iqn5bpizlwIlLMSs/wVr/uCQbLMvAAL wvKbAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAMYEWzDtbjYlqOWtuaCUw2S3fJFB +IWwWVsu0LN6+a1OPIDpAb5/ueKGv4CNDi5bXLTSP2or4CsWpz4mzK0Zp3Gt12uG NeOI4IUOd+5c+X+eF8fuW42luXBXHsNZPT7HNFCVV2XmhtOE90TsR/qPVH4llDlJ K+aHk9dd/PCSgG6+S7wwQhUxLdM7prns6RmPbUT2Sr3r57jS3JJF56Ejk2/LLmNK XHPO+a5hOBuEcwpEtuBB64/uuY1z+5vLddFl/8snHbWAZEQdUD1k9Vo7XXmP/6ac fYc0k0zdhJcqg45ftWumTWuPBVxx78TdK6k5nN9+TDgB7gSnjCyu4JyAl0w = -----END CERTIFICATE----- --- Server certificate subject = /C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com issuer = /C = CN/ST = BJ/L = beijing/O = f5/OU = zong.f5.com/CN = a.zong.f5.com/emailAddress = a.zong@f5.com --- No client certificate CA names sent Server Temp Key: ECDH, P-256, 256 bits --- SSL handshake has read 1413 bytes and written 413 bytes --- New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256 Server public key is 2048 bit Secure Renegotiation IS supported Compression: NONE Expansion: NONE No ALPN negotiated SSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-AES128-GCM-SHA256 Session-ID: 80DFB369B58206AD28679B31DC8B6EF44E39B1569845E592F02644A52C9B3E85 Session-ID-ctx: Master-Key: 1076BE0419F11D713BE98913481C861EB2DB5012279DDA861095DE4460DF05633ED12A8CFEB6050E17937A938803617D Start Time: 1680753364 Timeout : 7200 ( sec ) Verify return code: 10 ( certificate has expired ) ---","title":"Verify the Server Certificate Details"},{"location":"guides/traffic-splitting/","text":"HTTP traffic splitting \u00b6 In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"HTTP Traffic Splitting"},{"location":"guides/traffic-splitting/#http-traffic-splitting","text":"In this usecase, we will understand the slightly more complex application method of HTTPRoute . You can implement the grayscale publishing of the application through HTTPRoute , and smoothly transition traffic to new services. See here for GatwayClass and Gateway definitions. --- apiVersion : gateway.networking.k8s.io/v1beta1 kind : HTTPRoute metadata : name : myhttproute spec : parentRefs : - name : mygateway sectionName : http hostnames : - gateway.test.automation rules : - matches : - path : type : PathPrefix value : /test1 backendRefs : - name : coffee port : 80 weight : 1 - name : tea port : 80 weight : 9 - matches : - path : type : PathPrefix value : /test2 backendRefs : - name : coffee port : 80 weight : 9 - name : tea port : 80 weight : 1 Refer here for services tea and coffee definition. In the above httproute definition, we see that there are two rules: when we access /test1 , 90% of the traffic is forwarded to the tea service when we access /test2 , 90% of the traffic is forwarded to the coffee service You may change the two ratios, and run kubectl apply -f httproute.yaml again to achieve a change in the traffic ratio.","title":"HTTP traffic splitting"},{"location":"guides-next/getstarted/","text":"Getting started with BIG-IP Next Kubernetes Gateway Controller \u00b6 TODO We are actively work on this. Will update.","title":"Getting started"},{"location":"guides-next/getstarted/#getting-started-with-big-ip-next-kubernetes-gateway-controller","text":"TODO We are actively work on this. Will update.","title":"Getting started with BIG-IP Next Kubernetes Gateway Controller"},{"location":"quick-start/","text":"Get Started \u00b6 You\u2019ll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: bigip-kubernetes-gateway controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster kubectl cluster-info shows). If the controller runs in In-Cluster mode, it will depends on the serviceaccount and role/role-binding described in installation . Kubernetes Setup For Gateway API Integration \u00b6 After you have a K8s cluster, we need to configure it for different CNI types to make sure connection between BIG-IP and kubernetes cluster is OK. Note: To enable Gateway API integration via BIG-IP, actually, we need to configure both sides of BIG-IPs and the Kubernetes cluster, however, the BIG-IP side is configured by controller itself automatically when the controller is started. Here, we only need to configure Kubernetes side manually. For different CNIs, we have different configuration steps as following. In Flannel mode \u00b6 In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node to the Kubernetes. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node. In Calico mode \u00b6 In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"Get Started"},{"location":"quick-start/#get-started","text":"You\u2019ll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: bigip-kubernetes-gateway controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster kubectl cluster-info shows). If the controller runs in In-Cluster mode, it will depends on the serviceaccount and role/role-binding described in installation .","title":"Get Started"},{"location":"quick-start/#kubernetes-setup-for-gateway-api-integration","text":"After you have a K8s cluster, we need to configure it for different CNI types to make sure connection between BIG-IP and kubernetes cluster is OK. Note: To enable Gateway API integration via BIG-IP, actually, we need to configure both sides of BIG-IPs and the Kubernetes cluster, however, the BIG-IP side is configured by controller itself automatically when the controller is started. Here, we only need to configure Kubernetes side manually. For different CNIs, we have different configuration steps as following.","title":"Kubernetes Setup For Gateway API Integration"},{"location":"quick-start/#in-flannel-mode","text":"In flannel network mode, we need to create a BIG-IP virtual node to connect the BIG-IP node to the Kubernetes. In the following configuration sample, we use: BIG-IP traffic IP(Flannel VXLAN SelfIP): 10.250.18.105 BIG-IP traffic Mac(Flannel VXLAN Tunnel MAC): fa:16:3e:d5:28:07 (see below for the way to get it) podCIDR(BIGIP Flannel Subnet): 10.42.20.0/24 (see below for how to determine it) -> Create and edit the following yaml configuration file bigip1.yaml : bigip1.yaml: apiVersion : v1 kind : Node metadata : name : bigip1 annotations : # Replace IP with Self-IP for your deployment flannel.alpha.coreos.com/public-ip : \"10.250.18.105\" # uncomment the following line if using v6 tunnel and modify bigip v6 address # flannel.alpha.coreos.com/public-ipv6: \"2021:15::125\" # Replace MAC with your BIGIP Flannel VXLAN Tunnel MAC flannel.alpha.coreos.com/backend-data : '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' # uncomment the following line if using v6 tunnel and modify mac accordingly # flannel.alpha.coreos.com/backend-v6-data: '{\"VtepMAC\":\"fa:16:3e:d5:28:07\"}' flannel.alpha.coreos.com/backend-type : \"vxlan\" flannel.alpha.coreos.com/kube-subnet-manager : \"true\" spec : # Replace Subnet with your BIGIP Flannel Subnet podCIDR : \"10.42.20.0/24\" # uncomment the following 3 lines if using v6 tunnel and modify CIDRs using real data #podCIDRs: #- \"10.42.20.0/24\" #- \"2021:118:2:2::/64\" The mac address VtepMAC can be obtained using the TMSH command on BIG-IP: $ show net tunnels tunnel fl-tunnel all-properties $ show net tunnels tunnel fl-tunnel6 all-properties The pod CIDR podCIDR varies and should not be duplicated with the kubernetes cluster's pod CIDRs, see it by: kubectl get node -o yaml | grep podCIDR -> Execute kubectl apply -f bigip1.yaml command to create the above virtual node.","title":"In Flannel mode"},{"location":"quick-start/#in-calico-mode","text":"In calico mode, we need to peer BIG-IP(s) as the BGP neighbors of Kubernetes nodes. In the following configuration sample, we use: AS(Autonomous System): 64512 BIG-IP traffic IP: 10.250.17.111 On master node, -> Run the command to get calicoctl command line: $ curl -O -L https://github.com/projectcalico/calicoctl/releases/download/v3.10.0/calicoctl ` $ chmod +x calicoctl $ sudo mv calicoctl /usr/local/bin -> Edit /etc/calico/calico.ctl.cfg file $ sudo mkdir /etc/calico $ vim /etc/calico/calicoctl.cfg calicoctl.cfg apiVersion : projectcalico.org/v3 kind : CalicoAPIConfig metadata : spec : datastoreType : \"kubernetes\" kubeconfig : \"/root/.kube/config\" # change to actual kubeconfig path -> Run calicoctl get nodes to verify calicoctl runtime works OK. -> Run the following command to create BGP Group: cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPConfiguration metadata: name: default spec: logSeverityScreen: Info nodeToNodeMeshEnabled: true asNumber: 64512 EOF -> Run the following command to create BIG-IP peer for the kubernetes cluster. Notes : Change the peerIP to actual BIG-IP traffic IP(the selfIP for data traffic). cat << EOF | calicoctl create -f - apiVersion: projectcalico.org/v3 kind: BGPPeer metadata: name: bgppeer-bigip1 spec: peerIP: 10.250.17.111 asNumber: 64512 EOF -> After the configuration, we can use calicoctl node status command to check the BIG-IP peer status: $ calicoctl node status Calico process is running. IPv4 BGP status +---------------+-------------------+-------+----------+-------------+ | PEER ADDRESS | PEER TYPE | STATE | SINCE | INFO | +---------------+-------------------+-------+----------+-------------+ | 10 .250.17.182 | node-to-node mesh | up | 03 :07:33 | Established | | 10 .250.17.111 | global | up | 06 :18:28 | Established | +---------------+-------------------+-------+----------+-------------+ More references, see https://f5-k8s-istio-lab.readthedocs.io/en/latest/BGP/introduction.html","title":"In Calico mode"},{"location":"quick-start/installation/","text":"Installation \u00b6 In the code repository , we provide the Gateway API deployment yaml files for installation. The deployment yaml files are located at: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/deploy . The files are numbered and can complete the deployment process in order, where: file name functionality notes 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy bigip-kubernetes-gateway controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster watching CRUD events for gateway-related resources. View deployment results via kubectl get deployment -n kube-system . View the run log via kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters .","title":"Installation"},{"location":"quick-start/installation/#installation","text":"In the code repository , we provide the Gateway API deployment yaml files for installation. The deployment yaml files are located at: https://github.com/f5devcentral/bigip-kubernetes-gateway/tree/master/deploy . The files are numbered and can complete the deployment process in order, where: file name functionality notes 1.clusterrole-and-binding.yaml Create a user and role with corresponding operation permissions in the k8S cluster No further input is required 2.install-kubernetes-gatewayapi-CRDs.yaml Install the gateway API CRD and admission deployments No further input is required 3.deploy-bigip-kubernetes-gateway-controller.yaml Deploy bigip-kubernetes-gateway controller Required inputs by user to change BIGIP password: , BIGIP Configurations in bigips: and image version in image: Execute the kubectl command separately in order: $ kubectl apply -f 1 .clusterrole-and-binding.yaml $ kubectl apply -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl apply -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml After doing them, the bigip-kubernetes-gateway controller runs as a pod in kube-system namespace of the kubernetes cluster watching CRUD events for gateway-related resources. View deployment results via kubectl get deployment -n kube-system . View the run log via kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system For configuration defails in mentioned yaml files, see Controller Parameters .","title":"Installation"},{"location":"quick-start/parameters/","text":"Parameters \u00b6 The examples of the parameters are available in the deployment yaml file placed on the code repository: deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml . There are 2 parts of BIG-IP configurations: The password of BIG-IP passed in via a Kubernetes Secret(Part 1). Some additional BIG-IP configuration information passed in via a separate Kubernetes Configmap(Part 2). In the controller deployment yaml file(Part 3), the two parts of configurations are passed in the form of volume, and the controller reads the specific configuration content of the indicated paths. Part 1: bigip-login \u00b6 --- apiVersion : v1 kind : Secret metadata : name : bigip-login namespace : kube-system data : password : UEBzc3cwcmQxMjM= # base64 password for admin type : Opaque BIG-IP's password for admin is stored in a separate Secret type resource for security concern. Part 2: bigip-kubernetes-gateway-configmap \u00b6 --- apiVersion : v1 kind : ConfigMap metadata : name : bigip-kubernetes-gateway-configmap namespace : kube-system data : bigip-kubernetes-gateway-config : | - management: username: admin ipAddress: 10.250.15.180 port: 443 flannel: tunnels: - name: fl-tunnel profileName: fl-vxlan port: 8472 localAddress: 10.250.18.119 selfIPs: - name: flannel-self ipMask: 10.42.20.1/16 tunnelName: fl-tunnel calico: localAS: &as 64512 remoteAS: *as Within the above configmap, it stores BIG-IP configuration for network setup and resource managements. The controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are: # BIG-IP management info - management : # username, must be amdin currently username : admin # management IP address for iControl Rest ipAddress : 10.250.15.180 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) localAddress : 10.250.18.119 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # tunnel name, should match one of the tunnels tunnelName : fl-tunnel # optional, underlay network configuration for calico CNI mode calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as Note that, If we don't want to configure BIG-IP in flannel mode, just remove/comment the flannel parts. It's same to calico case. Futher, if we don't want to configure BIG-IP at all, remove/comment both of them, the controller will keep the CNI configurations on BIG-IP as user configure them manually in advance. Part 3: bigip-kubernetes-gateway deployment and service \u00b6 --- apiVersion : apps/v1 kind : Deployment metadata : name : bigip-kubernetes-gateway namespace : kube-system spec : replicas : 1 #... spec : serviceAccountName : k8s-bigip-ctlr nodeSelector : node-role.kubernetes.io/control-plane : \"true\" # node-role.kubernetes.io/master: \"true\" containers : # use `kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system` for tracing. - name : bigip-kubernetes-gateway-pod image : f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 imagePullPolicy : IfNotPresent command : [ \"/bigip-kubernetes-gateway-controller-linux\" ] args : [ \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , ] volumeMounts : - name : bigip-credential mountPath : \"/bigip-credential\" readOnly : true - name : bigip-config mountPath : /bigip-config readOnly : true volumes : - name : bigip-credential secret : secretName : bigip-login - name : bigip-config configMap : name : bigip-kubernetes-gateway-configmap For the yaml file above, let's pay attention to image , args , volumeMounts and volumes parts. For details about the usage of the file, See installation .","title":"Parameters"},{"location":"quick-start/parameters/#parameters","text":"The examples of the parameters are available in the deployment yaml file placed on the code repository: deploy/3.deploy-bigip-kubernetes-gateway-controller.yaml . There are 2 parts of BIG-IP configurations: The password of BIG-IP passed in via a Kubernetes Secret(Part 1). Some additional BIG-IP configuration information passed in via a separate Kubernetes Configmap(Part 2). In the controller deployment yaml file(Part 3), the two parts of configurations are passed in the form of volume, and the controller reads the specific configuration content of the indicated paths.","title":"Parameters"},{"location":"quick-start/parameters/#part-1-bigip-login","text":"--- apiVersion : v1 kind : Secret metadata : name : bigip-login namespace : kube-system data : password : UEBzc3cwcmQxMjM= # base64 password for admin type : Opaque BIG-IP's password for admin is stored in a separate Secret type resource for security concern.","title":"Part 1: bigip-login"},{"location":"quick-start/parameters/#part-2-bigip-kubernetes-gateway-configmap","text":"--- apiVersion : v1 kind : ConfigMap metadata : name : bigip-kubernetes-gateway-configmap namespace : kube-system data : bigip-kubernetes-gateway-config : | - management: username: admin ipAddress: 10.250.15.180 port: 443 flannel: tunnels: - name: fl-tunnel profileName: fl-vxlan port: 8472 localAddress: 10.250.18.119 selfIPs: - name: flannel-self ipMask: 10.42.20.1/16 tunnelName: fl-tunnel calico: localAS: &as 64512 remoteAS: *as Within the above configmap, it stores BIG-IP configuration for network setup and resource managements. The controller would configure the BIG-IPs as specified to make sure the data plane connection between BIG-IP and the kubernetes cluster is OK. The meaning of fields are: # BIG-IP management info - management : # username, must be amdin currently username : admin # management IP address for iControl Rest ipAddress : 10.250.15.180 # optional, management port, default to 443 port : 443 # optional, overlay network configuration for flannel CNI mode flannel : # tunnels configuration tunnels : # tunnel name - name : fl-tunnel # tunnel profile name for binding to the very tunnel profileName : fl-vxlan # tunnel profile port for binding to the very tunnel port : 8472 # the local address for the tunnel(VTEP) localAddress : 10.250.18.119 # selfips configuration selfIPs : # the name of the self IP address definition - name : flannel-self # the IP address associated to the vxlan tunnel ipMask : 10.42.20.1/16 # tunnel name, should match one of the tunnels tunnelName : fl-tunnel # optional, underlay network configuration for calico CNI mode calico : # AS num on BIG-IP side localAS : &as 64512 # AS num on K8S side, generally, it's same as localAS remoteAS : *as Note that, If we don't want to configure BIG-IP in flannel mode, just remove/comment the flannel parts. It's same to calico case. Futher, if we don't want to configure BIG-IP at all, remove/comment both of them, the controller will keep the CNI configurations on BIG-IP as user configure them manually in advance.","title":"Part 2: bigip-kubernetes-gateway-configmap"},{"location":"quick-start/parameters/#part-3-bigip-kubernetes-gateway-deployment-and-service","text":"--- apiVersion : apps/v1 kind : Deployment metadata : name : bigip-kubernetes-gateway namespace : kube-system spec : replicas : 1 #... spec : serviceAccountName : k8s-bigip-ctlr nodeSelector : node-role.kubernetes.io/control-plane : \"true\" # node-role.kubernetes.io/master: \"true\" containers : # use `kubectl logs -f deployment/bigip-kubernetes-gateway -c bigip-kubernetes-gateway-pod -n kube-system` for tracing. - name : bigip-kubernetes-gateway-pod image : f5devcentral/bigip-kubernetes-gateway:v0.0.4-20221219 imagePullPolicy : IfNotPresent command : [ \"/bigip-kubernetes-gateway-controller-linux\" ] args : [ \"--controller-name=f5.io/gateway-controller-name\" , \"--bigip-config-directory=/bigip-config\" , \"--bigip-credential-directory=/bigip-credential\" , ] volumeMounts : - name : bigip-credential mountPath : \"/bigip-credential\" readOnly : true - name : bigip-config mountPath : /bigip-config readOnly : true volumes : - name : bigip-credential secret : secretName : bigip-login - name : bigip-config configMap : name : bigip-kubernetes-gateway-configmap For the yaml file above, let's pay attention to image , args , volumeMounts and volumes parts. For details about the usage of the file, See installation .","title":"Part 3: bigip-kubernetes-gateway deployment and service"},{"location":"quick-start/uninstall/","text":"Uninstallation \u00b6 The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Uninstallation"},{"location":"quick-start/uninstall/#uninstallation","text":"The uninstall process is executed in reverse order to the installation process. You can refer to the deployment file described in the installation section, and execute the following commands to complete the uninstallation: $ kubectl delete -f 3 .deploy-bigip-kubernetes-gateway-controller.yaml $ kubectl delete -f 2 .install-kubernetes-gatewayapi-CRDs.yaml $ kubectl delete -f 1 .clusterrole-and-binding.yaml","title":"Uninstallation"}]}